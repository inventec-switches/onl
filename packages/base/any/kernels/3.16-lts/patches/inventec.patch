diff -Naur linux-3_16_53_old/include/linux/inventec/common/inventec_sysfs.h linux-3_16_53_new/include/linux/inventec/common/inventec_sysfs.h
--- linux-3_16_53_old/include/linux/inventec/common/inventec_sysfs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/common/inventec_sysfs.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,166 @@
+#ifndef _INVENTEC_SYSFS_H_
+#define _INVENTEC_SYSFS_H_
+
+/* Module informations */
+#define INV_SYSFS_AUTHOR    "Robert <yu.robertxk@inventec.com>"
+#define INV_SYSFS_DESC      "Inventec Platform Sysfs System"
+#define INV_SYSFS_LICENSE   "GPL"
+#define INV_SYSFS_VERSION   "version 2.0.5"
+#define INV_SYSFS_RL_DATE   "July 7, 2017"
+
+#define INVENTEC_CLASS_NAME	"inventec"
+#define SYSTEM_DEVICE_NAME	"system"
+#define PORTS_DEVICE_NAME	"ports"
+#define PORTSINFO_DEVICE_NAME	"portsinfo"
+#define PSU_DEVICE_NAME		"psus"
+#define PSUINFO_DEVICE_NAME	"psuinfo"
+#define LED_DEVICE_NAME		"leds"
+#define LEDINFO_DEVICE_NAME	"ledinfo"
+#define FAN_DEVICE_NAME		"fans"
+#define FANINFO_DEVICE_NAME	"faninfo"
+#define SENSOR_DEVICE_NAME	"sensors"
+#define SENSORINFO_DEVICE_NAME	"sensorinfo"
+
+#if 0
+//#define SYSFS_LOG(fmt, args...) printk(KERN_WARNING "[SYSFS] %s/%d: " fmt, __func__, __LINE__, ##args)
+#define SYSFS_LOG(fmt, args...) printk(KERN_WARNING "[SYSFS] " fmt, ##args)
+#else
+/* For timestamps in SYSFS_LOG */
+extern void SYSFS_LOG(char *fmt, ...);
+#endif
+#define SHOW_ATTR_WARNING	("N/A")
+#define SHOW_ATTR_NOTPRINT	("Not Available")
+
+#define INV_MAX_LEN_CHAR_STRING	(32)
+#define INV_MAX_LEN_SYS_VERSION	(3)
+
+/*
+ * Platform Identifier for system build
+ * Only one turned on
+ *
+#define PLATFORM_MAGNOLIA
+#define PLATFORM_REDWOOD
+#define PLATFORM_CYPRESS
+#define PLATFORM_SPRUCE
+ *
+ * For yocto/redwood image only
+#define YOCTO_REDWOOD
+ */
+#define PLATFORM_REDWOOD
+
+#if defined PLATFORM_MAGNOLIA
+/*
+ * Magnolia ports
+ * 48 SFP ports and 6 QSFP ports
+ * port number in inventec /sys/class/swps is 0 based.
+ * We convert it to 1 based in inventec sysfs
+ */
+#define PORT_SFP_DEV_START	(0)
+#define PORT_SFP_DEV_TOTAL	(PORT_SFP_DEV_START + 48)
+#define PORT_QSFP_DEV_START	(PORT_SFP_DEV_TOTAL)
+#define PORT_QSFP_DEV_TOTAL	(PORT_QSFP_DEV_START + 6)
+#define PORTS_NUMBER_TOTAL	(PORT_QSFP_DEV_TOTAL - PORT_SFP_DEV_START)
+
+#define SYSFS_SFP_DEV_START	(1)
+#define SYSFS_SFP_DEV_END	(PORT_SFP_DEV_TOTAL)
+#define SYSFS_QSFP_DEV_START	(PORT_QSFP_DEV_START + 1)
+#define SYSFS_QSFP_DEV_END	(PORT_QSFP_DEV_TOTAL)
+#define SYSFS_NUMBER_TOTAL	(PORTS_NUMBER_TOTAL)
+
+#define INV_CPLD_NUMBER		1
+//TOBE MOVED #define INV_MAG_PSU_MODEL	"DPS-460DB-9A"
+//#define INV_PSU_MODULE_NAME	"DPS-460DB-9A"
+
+#elif defined PLATFORM_REDWOOD
+/*
+ * Redwood ports
+ * 0 SFP ports and 32 QSFP ports
+ * port number in inventec /sys/class/swps is 0 based.
+ * We convert it to 1 based in inventec sysfs
+ */
+#define PORT_SFP_DEV_START	(0)
+#define PORT_SFP_DEV_TOTAL	(PORT_SFP_DEV_START + 0)
+#define PORT_QSFP_DEV_START	(PORT_SFP_DEV_TOTAL)
+#define PORT_QSFP_DEV_TOTAL	(PORT_QSFP_DEV_START + 32)
+#define PORTS_NUMBER_TOTAL	(PORT_QSFP_DEV_TOTAL - PORT_SFP_DEV_START)
+
+#define SYSFS_SFP_DEV_START	(1)
+#define SYSFS_SFP_DEV_END	(PORT_SFP_DEV_TOTAL)
+#define SYSFS_QSFP_DEV_START	(PORT_QSFP_DEV_START + 1)
+#define SYSFS_QSFP_DEV_END	(PORT_QSFP_DEV_TOTAL)
+#define SYSFS_NUMBER_TOTAL	(PORTS_NUMBER_TOTAL)
+
+#define INV_CPLD_NUMBER		1
+#define INV_PSU_MODULE_NAME	"Redwood PSU Model Name"
+
+#elif defined PLATFORM_CYPRESS
+/*
+ * Cypress ports
+ */
+TBD
+#define INV_PSU_MODULE_NAME	"Cypress PSU Model Name"
+#endif
+
+typedef struct dev_child_tracking_s {
+	dev_t devt;
+	struct device *dev;
+	struct dev_child_tracking_s *next;
+} dev_child_tracking_t;
+
+extern struct class *inventec_get_class(void);
+extern struct device *inventec_child_device_create(struct device *parent,
+              dev_t devt, void *drvdata, const char *fmt, void *tracking);
+extern void inventec_child_device_destroy(void *tracking);
+
+extern ssize_t inventec_show_attr(char *buf_p, const char *invdevp);
+extern ssize_t inventec_store_attr(const char *buf_p, size_t count, const char *invdevp);
+extern ssize_t inventec_show_bin_attr(char *buf_p, char *invdevp, int pos);
+extern ssize_t inventec_show_attr_pos(char *buf_p, char *invdevp, int pos);
+
+/*
+ * LED definitions
+ */
+#define STATUS_LED_MODE_AUTO	0
+#define STATUS_LED_MODE_DIAG	1
+#define STATUS_LED_MODE_MANU	2
+
+#define STATUS_LED_GRN0		10      // 0 - 000: off
+#define STATUS_LED_GRN1		11      // 1 - 001: 0.5hz
+#define STATUS_LED_GRN2		12      // 2 - 010: 1 hz
+#define STATUS_LED_GRN3		13      // 3 - 011: 2 hz
+#define STATUS_LED_GRN7		17      // 7 - 111: on
+#define STATUS_LED_RED0		20      // 0 - 000: off
+#define STATUS_LED_RED1		21      // 1 - 001: 0.5hz
+#define STATUS_LED_RED2		22      // 2 - 010: 1 hz
+#define STATUS_LED_RED3		23      // 3 - 011: 2 hz
+#define STATUS_LED_RED7		27      // 7 - 111: on
+#define STATUS_LED_INVALID	0	// Invalid
+
+#define STATUS_LED_GRN_PATH	"/sys/class/hwmon/hwmon1/device/grn_led"
+#define STATUS_LED_RED_PATH	"/sys/class/hwmon/hwmon1/device/red_led"
+
+#define FAN_LED_GRN1_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_grn1"
+#define FAN_LED_GRN2_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_grn2"
+#define FAN_LED_GRN3_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_grn3"
+#define FAN_LED_GRN4_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_grn4"
+#define FAN_LED_RED1_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_red1"
+#define FAN_LED_RED2_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_red2"
+#define FAN_LED_RED3_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_red3"
+#define FAN_LED_RED4_PATH	"/sys/class/hwmon/hwmon0/device/fan_led_red4"
+
+#define HWMON_DEVICE_DIAG_PATH	"/sys/class/hwmon/hwmon0/device/diag"
+#define HWMON_DEVICE_CTL_PATH	"/sys/class/hwmon/hwmon1/device/ctl"
+
+extern ssize_t status_led_change(const char *path1, const char *tmp1, const char *path2, const char *tmp2);
+extern ssize_t status_led_diag_mode_enable(void);
+extern ssize_t status_led_diag_mode_disable(void);
+extern int status_led_check_color(void);
+extern int status_led_check_diag_mode(void);
+extern int psu_check_state_normal(char *statep);
+extern int inventec_store_input(char *inputp, int count);
+extern int inventec_strtol(const char *sbufp, char **endp, unsigned int base);
+#ifdef YOCTO_REDWOOD
+extern void led_set_gpio_to_change_status_led(void);
+#endif
+
+#endif
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/inv_mux.h linux-3_16_53_new/include/linux/inventec/cypress/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/cypress/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/inv_mux.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/inv_swps.h linux-3_16_53_new/include/linux/inventec/cypress/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/cypress/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/inv_swps.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,734 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_CYPRESS_GA2
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/inv_vpd.h linux-3_16_53_new/include/linux/inventec/cypress/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/cypress/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/inv_vpd.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/io_expander.h linux-3_16_53_new/include/linux/inventec/cypress/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/cypress/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/io_expander.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,169 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/cypress/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/cypress/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/onie_tlvinfo.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/cypress/transceiver.h linux-3_16_53_new/include/linux/inventec/cypress/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/cypress/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/cypress/transceiver.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,792 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/inv_mux.h linux-3_16_53_new/include/linux/inventec/d5254/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/d5254/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/inv_mux.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,41 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+#define MUX_RST_GPIO_249_PCA9548        (249)
+#define MUX_RST_GPIO_500_PAC9548        (500)
+#define MUX_RST_GPIO_505_PCA9548        (505)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/inv_swps.h linux-3_16_53_new/include/linux/inventec/d5254/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/d5254/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/inv_swps.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,1265 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.10"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO                (100)
+#define PLATFORM_TYPE_MAGNOLIA            (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC        (112)
+#define PLATFORM_TYPE_REDWOOD             (121)
+#define PLATFORM_TYPE_REDWOOD_FSL         (122)
+#define PLATFORM_TYPE_HUDSON32I_GA        (131)
+#define PLATFORM_TYPE_SPRUCE              (141)
+#define PLATFORM_TYPE_CYPRESS_GA1         (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2         (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI         (153) /* Down -> Up */
+#define PLATFORM_TYPE_TAHOE               (161)
+#define PLATFORM_TYPE_SEQUOIA_GA          (171)
+#define PLATFORM_TYPE_LAVENDER_GA         (181)
+#define PLATFORM_TYPE_LAVENDER_ONL        (182)
+#define PLATFORM_TYPE_COTTONWOOD_RANGELEY (191)
+#define PLATFORM_TYPE_MAPLE               (201)
+#define PLATFORM_TYPE_GULMOHAR_GA         (202)
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_GULMOHAR_GA
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA             (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA             (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD              (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL          (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA         (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE               (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1          (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2          (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI          (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_TAHOE)
+  #define SWPS_TAHOE                (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SEQUOIA_GA)
+  #define SWPS_SEQUOIA              (1)
+  #define SWPS_KERN_VER_BF_3_8      (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_GA)
+  #define SWPS_LAVENDER             (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_ONL)
+  #define SWPS_LAVENDER             (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_COTTONWOOD_RANGELEY)
+  #define SWPS_COTTONWOOD_RANGELEY  (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAPLE)
+  #define SWPS_MAPLE                (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_GULMOHAR_GA)
+  #define SWPS_GULMOHAR             (1)
+  #define SWPS_KERN_VER_AF_3_10     (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,                 "Auto-Detect"         },
+    {PLATFORM_TYPE_MAGNOLIA,             "Magnolia"            },
+    {PLATFORM_TYPE_MAGNOLIA_FNC,         "Magnolia_FNC"        },
+    {PLATFORM_TYPE_REDWOOD,              "Redwood"             },
+    {PLATFORM_TYPE_REDWOOD_FSL,          "Redwood_FSL"         },
+    {PLATFORM_TYPE_HUDSON32I_GA,         "Hudson32i"           },
+    {PLATFORM_TYPE_SPRUCE,               "Spruce"              },
+    {PLATFORM_TYPE_CYPRESS_GA1,          "Cypress_GA1"         },
+    {PLATFORM_TYPE_CYPRESS_GA2,          "Cypress_GA2"         },
+    {PLATFORM_TYPE_CYPRESS_BAI,          "Cypress_BAI"         },
+    {PLATFORM_TYPE_TAHOE,                "Tahoe"               },
+    {PLATFORM_TYPE_SEQUOIA_GA,           "Sequoia_GA"          },
+    {PLATFORM_TYPE_LAVENDER_GA,          "Lavender_GA"         },
+    {PLATFORM_TYPE_LAVENDER_ONL,         "Lavender_ONL"        },
+    {PLATFORM_TYPE_COTTONWOOD_RANGELEY,  "Cottonwood_RANGELEY" },
+    {PLATFORM_TYPE_MAPLE,                "Maple"               },
+    {PLATFORM_TYPE_GULMOHAR_GA,          "Gulmohar_GA"         },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_4AB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander 4 A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf0, 0xff}, {0xf0, 0xff}, }, }, /* addr[1] = I/O Expander 4 B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Tahoe Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_TAHOE
+unsigned tahoe_gpio_rest_mux = MUX_RST_GPIO_249_PCA9548;
+
+struct inv_ioexp_layout_s tahoe_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_TAHOE_6ABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[0] = I/O Expander 6 A */
+                                  {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[1] = I/O Expander 6 B */
+                                  {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {1,  IOEXP_TYPE_TAHOE_5A,   { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[0] = I/O Expander 5 A */
+    },
+};
+
+
+struct inv_port_layout_s tahoe_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  12,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    { 1,  11,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    { 2,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    { 3,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    { 4,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    { 5,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    { 6,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    { 7,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    { 8,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    { 9,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Sequoia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SEQUOIA
+unsigned sequoia_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s sequoia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SEQUOIA_NABC, { {1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    {1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    {1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_SEQUOIA_NABC, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1 A */
+                                    {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1 B */
+                                    {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 1 C */
+    },
+    {2,  IOEXP_TYPE_SEQUOIA_NABC, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 2 A */
+                                    {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 2 B */
+                                    {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 2 C */
+    },
+    {3,  IOEXP_TYPE_SEQUOIA_NABC, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 3 A */
+                                    {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 3 B */
+                                    {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 3 C */
+    },
+    {4,  IOEXP_TYPE_SEQUOIA_NABC, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 4 A */
+                                    {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 4 B */
+                                    {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 4 C */
+    },
+    {5,  IOEXP_TYPE_SEQUOIA_NABC, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 5 A */
+                                    {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 5 B */
+                                    {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 C */
+    },
+    {6,  IOEXP_TYPE_SEQUOIA_NABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 6 A */
+                                    {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 6 B */
+                                    {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {7,  IOEXP_TYPE_SEQUOIA_NABC, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 7 A */
+                                    {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                    {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+
+struct inv_port_layout_s sequoia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   9,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9,  10,  11,  12} },
+    { 1,  10,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,   2,   3,   4} },
+    { 2,  11,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25,  26,  27,  28} },
+    { 3,  12,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17,  18,  19,  20} },
+    { 4,  13,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41,  42,  43,  44} },
+    { 5,  14,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33,  34,  35,  36} },
+    { 6,  15,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57,  58,  59,  60} },
+    { 7,  16,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49,  50,  51,  52} },
+    { 8,  17,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73,  74,  75,  76} },
+    { 9,  18,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    {10,  19,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89,  90,  91,  92} },
+    {11,  20,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    {12,  21,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    {13,  22,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    {14,  23,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121, 122, 123, 124} },
+    {15,  24,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    {16,  25,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {137, 138, 139, 140} },
+    {17,  26,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {129, 130, 131, 132} },
+    {18,  27,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {153, 154, 155, 156} },
+    {19,  28,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {145, 146, 147, 148} },
+    {20,  29,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {169, 170, 171, 172} },
+    {21,  30,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {161, 162, 163, 164} },
+    {22,  31,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {185, 186, 187, 188} },
+    {23,  32,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {177, 178, 179, 180} },
+    {24,  33,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {201, 202, 203, 204} },
+    {25,  34,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {193, 194, 195, 196} },
+    {26,  35,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {217, 218, 219, 220} },
+    {27,  36,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {209, 210, 211, 212} },
+    {28,  37,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {233, 234, 235, 236} },
+    {29,  38,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {225, 226, 227, 228} },
+    {30,  39,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {249, 250, 251, 252} },
+    {31,  40,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {241, 242, 243, 244} },
+    {32,  44,  4,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13,  14,  15,  16} },
+    {33,  43,  4,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,   6,   7,   8} },
+    {34,  42,  4,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29,  30,  31,  32} },
+    {35,  41,  4,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21,  22,  23,  24} },
+    {36,  48,  4,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45,  46,  47,  48} },
+    {37,  47,  4,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37,  38,  39,  40} },
+    {38,  46,  4,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61,  62,  63,  64} },
+    {39,  45,  4,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    {40,  52,  5,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77,  78,  79,  80} },
+    {41,  51,  5,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    {42,  50,  5,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93,  94,  95,  96} },
+    {43,  49,  5,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    {44,  56,  5,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+    {45,  55,  5,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    {46,  54,  5,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125, 126, 127, 128} },
+    {47,  53,  5,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117, 118, 119, 120} },
+    {48,  60,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {141, 142, 143, 144} },
+    {49,  59,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {133, 134, 135, 136} },
+    {50,  58,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {157, 158, 159, 160} },
+    {51,  57,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {149, 150, 151, 152} },
+    {52,  64,  6,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {173, 174, 175, 176} },
+    {53,  63,  6,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {165, 166, 167, 168} },
+    {54,  62,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {189, 190, 191, 192} },
+    {55,  61,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {181, 182, 183, 184} },
+    {56,  68,  7,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {205, 206, 207, 208} },
+    {57,  67,  7,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {197, 198, 199, 200} },
+    {58,  66,  7,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {221, 222, 223, 224} },
+    {59,  65,  7,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {213, 214, 215, 216} },
+    {60,  72,  7,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {237, 238, 239, 240} },
+    {61,  71,  7,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {229, 230, 231, 232} },
+    {62,  70,  7,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {253, 254, 255, 256} },
+    {63,  69,  7,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {245, 246, 247, 248} },
+};
+#endif
+
+
+/* ==========================================
+ *   Lavender Layout configuration
+ * ==========================================
+ */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_GA)
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_505_PCA9548;
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_ONL)
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+#endif
+
+#ifdef SWPS_LAVENDER
+struct inv_ioexp_layout_s lavender_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SEQUOIA_NABC, { { 1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    { 1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    { 1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_SEQUOIA_NABC, { { 2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1 A */
+                                    { 2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1 B */
+                                    { 2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 1 C */
+    },
+    {2,  IOEXP_TYPE_SEQUOIA_NABC, { { 3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 2 A */
+                                    { 3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 2 B */
+                                    { 3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 2 C */
+    },
+    {3,  IOEXP_TYPE_SEQUOIA_NABC, { { 4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 3 A */
+                                    { 4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 3 B */
+                                    { 4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 3 C */
+    },
+    {4,  IOEXP_TYPE_SEQUOIA_NABC, { { 9, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 4 A */
+                                    { 9, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 4 B */
+                                    { 9, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 4 C */
+    },
+    {5,  IOEXP_TYPE_SEQUOIA_NABC, { {10, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 5 A */
+                                    {10, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 5 B */
+                                    {10, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 C */
+    },
+    {6,  IOEXP_TYPE_SEQUOIA_NABC, { {11, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 6 A */
+                                    {11, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 6 B */
+                                    {11, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {7,  IOEXP_TYPE_SEQUOIA_NABC, { {12, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 7 A */
+                                    {12, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                    {12, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+    {8,  IOEXP_TYPE_LAVENDER_P65, { { 5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xF6, 0xff}, {0xF8, 0xff}, }, }, /* addr[0] = I/O Expander CPU */
+    },
+};
+
+
+struct inv_port_layout_s lavender_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {188, 189, 190, 191} },
+    { 1,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {184, 185, 186, 187} },
+    { 2,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {180, 181, 182, 183} },
+    { 3,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {176, 177, 178, 179} },
+    { 4,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {172, 173, 174, 175} },
+    { 5,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {168, 169, 170, 171} },
+    { 6,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {164, 165, 166, 167} },
+    { 7,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {160, 161, 162, 163} },
+    { 8,  25,  1,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {156, 157, 158, 159} },
+    { 9,  26,  1,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {152, 153, 154, 155} },
+    {10,  27,  1,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {148, 149, 150, 151} },
+    {11,  28,  1,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {144, 145, 146, 147} },
+    {12,  29,  1,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {140, 141, 142, 143} },
+    {13,  30,  1,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {136, 137, 138, 139} },
+    {14,  31,  1,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {132, 133, 134, 135} },
+    {15,  32,  1,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {128, 129, 130, 131} },
+    {16,  33,  2,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  0,   1,   2,   3} },
+    {17,  34,  2,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  4,   5,   6,   7} },
+    {18,  35,  2,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  8,   9,  10,  11} },
+    {19,  36,  2,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 12,  13,  14,  15} },
+    {20,  37,  2,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 16,  17,  18,  19} },
+    {21,  38,  2,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 20,  21,  22,  23} },
+    {22,  39,  2,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 24,  25,  26,  27} },
+    {23,  40,  2,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 28,  29,  30,  31} },
+    {24,  41,  3,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 32,  33,  34,  35} },
+    {25,  42,  3,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 36,  37,  38,  39} },
+    {26,  43,  3,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 40,  41,  42,  43} },
+    {27,  44,  3,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 44,  45,  46,  47} },
+    {28,  45,  3,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 48,  49,  50,  51} },
+    {29,  46,  3,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 52,  53,  54,  55} },
+    {30,  47,  3,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 56,  57,  58,  59} },
+    {31,  48,  3,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 60,  61,  62,  63} },
+    {32,  49,  4,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {256, 257, 258, 259} },
+    {33,  50,  4,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {260, 261, 262, 263} },
+    {34,  51,  4,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {264, 265, 266, 267} },
+    {35,  52,  4,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {268, 269, 270, 271} },
+    {36,  53,  4,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {272, 273, 274, 275} },
+    {37,  54,  4,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {276, 277, 278, 279} },
+    {38,  55,  4,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {280, 281, 282, 283} },
+    {39,  56,  4,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {284, 285, 286, 287} },
+    {40,  57,  5,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {288, 289, 290, 291} },
+    {41,  58,  5,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {292, 293, 294, 295} },
+    {42,  59,  5,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {296, 297, 298, 299} },
+    {43,  60,  5,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {300, 301, 302, 303} },
+    {44,  61,  5,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {304, 305, 306, 307} },
+    {45,  62,  5,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {308, 309, 310, 311} },
+    {46,  63,  5,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {312, 313, 314, 315} },
+    {47,  64,  5,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {316, 317, 318, 319} },
+    {48,  65,  6,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {444, 445, 446, 447} },
+    {49,  66,  6,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {440, 441, 442, 443} },
+    {50,  67,  6,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {436, 437, 438, 439} },
+    {51,  68,  6,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {432, 433, 434, 435} },
+    {52,  69,  6,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {428, 429, 430, 431} },
+    {53,  70,  6,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {424, 425, 426, 427} },
+    {54,  71,  6,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {420, 421, 422, 423} },
+    {55,  72,  6,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {416, 417, 418, 419} },
+    {56,  73,  7,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {412, 413, 414, 415} },
+    {57,  74,  7,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {408, 409, 410, 411} },
+    {58,  75,  7,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {404, 405, 406, 407} },
+    {59,  76,  7,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {400, 401, 402, 403} },
+    {60,  77,  7,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {396, 397, 398, 399} },
+    {61,  78,  7,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {392, 393, 394, 395} },
+    {62,  79,  7,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {388, 389, 390, 391} },
+    {63,  80,  7,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {384, 385, 386, 387} },
+    {64,   5,  8,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 64,  65,  66,  67} },
+};
+#endif
+
+/* ===========================================================
+ *   Cottonwood Layout configuration Rangeley (Rangeley CPU board)
+ * ===========================================================
+ */
+#ifdef SWPS_COTTONWOOD_RANGELEY
+unsigned cottonwood_rangeley_gpio_rest_mux = MUX_RST_GPIO_500_PAC9548;
+
+struct inv_ioexp_layout_s cottonwood_rangeley_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  CPLD_TYPE_COTTONWOOD,{ {1, 0x55, {22, 23, 24, 25}, {22, 23, 24, 25}, {-1, -1, -1, -1}, {0xee, 0xee, 0x99, 0x99}, {0x00, 0x00, 0x00, 0x00}, },
+                              },
+    },
+};
+
+
+struct inv_port_layout_s cottonwood_rangeley_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHI_TYPE / LANE_ID */
+    { 0,  2,  0,  0, TRANSVR_TYPE_SFP, BCM_CHIP_TYPE_TOMAHAWK, { 75} },
+    { 1,  3,  0,  1, TRANSVR_TYPE_SFP, BCM_CHIP_TYPE_TOMAHAWK, { 77} },
+    { 2,  4,  0,  2, TRANSVR_TYPE_SFP, BCM_CHIP_TYPE_TOMAHAWK, { 79} },
+    { 3,  5,  0,  3, TRANSVR_TYPE_SFP, BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+};
+#endif
+
+/* ===========================================================
+ *   Maple Layout configuration
+ * ===========================================================
+ */
+#ifdef SWPS_MAPLE
+unsigned maple_gpio_rest_mux = MUX_RST_GPIO_505_PCA9548;
+
+struct inv_ioexp_layout_s maple_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAPLE_0ABC,   { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_MAPLE_NABC,   { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_MAPLE_NABC,   { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_MAPLE_NABC,   { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_MAPLE_NABC,   { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_MAPLE_NABC,   { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_MAPLE_NABC,   { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                    {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                    {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+};
+
+struct inv_port_layout_s maple_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  1} },
+    { 1,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  2} },
+    { 2,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  3} },
+    { 3,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  4} },
+    { 4,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  5} },
+    { 5,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  6} },
+    { 6,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  7} },
+    { 7,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, {  8} },
+    { 8,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 13} },
+    { 9,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 14} },
+    {10,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 15} },
+    {11,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 16} },
+    {12,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 21} },
+    {13,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 22} },
+    {14,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 23} },
+    {15,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 24} },
+    {16,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 29} },
+    {17,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 30} },
+    {18,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 31} },
+    {19,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 32} },
+    {20,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 33} },
+    {21,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 34} },
+    {22,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 35} },
+    {23,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 36} },
+    {24,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 41} },
+    {25,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 42} },
+    {26,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 43} },
+    {27,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 44} },
+    {28,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 49} },
+    {29,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 50} },
+    {30,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 51} },
+    {31,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 52} },
+    {32,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 57} },
+    {33,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 58} },
+    {34,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 59} },
+    {35,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 60} },
+    {36,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 61} },
+    {37,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 62} },
+    {38,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 63} },
+    {39,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 64} },
+    {40,  58,  6,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 65} },
+    {41,  59,  6,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 66} },
+    {42,  60,  6,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 67} },
+    {43,  61,  6,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 68} },
+    {44,  62,  6,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 69} },
+    {45,  63,  6,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 70} },
+    {46,  64,  6,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 71} },
+    {47,  65,  6,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TRIDENT_3, { 72} },
+    {48,  10,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, { 77, 78, 79, 80} },
+    {49,  11,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, { 85, 86, 87, 88} },
+    {50,  12,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, { 93, 94, 95, 96} },
+    {51,  13,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, { 97, 98, 99,100} },
+    {52,  14,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, {105,106,107,108} },
+    {53,  15,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, {113,114,115,116} },
+    {54,  16,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, {121,122,123,124} },
+    {55,  17,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TRIDENT_3, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Gulmohar Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_GULMOHAR
+unsigned gulmohar_gpio_rest_mux = MUX_RST_GPIO_505_PCA9548;
+
+struct inv_ioexp_layout_s gulmohar_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_GULMOHAR_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_GULMOHAR_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_GULMOHAR_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_GULMOHAR_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_GULMOHAR_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_GULMOHAR_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[0] = I/O Expander N A */
+                                      {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf3, 0xf3}, {0xf3, 0xf3}, },    /* addr[1] = I/O Expander N B */
+                                      {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_GULMOHAR_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                      {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                      {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+
+
+struct inv_port_layout_s gulmohar_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BF_CHIP_TYPE_TOFINO, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {109,110,111,112} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/inv_vpd.h linux-3_16_53_new/include/linux/inventec/d5254/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/d5254/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/inv_vpd.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/io_expander.h linux-3_16_53_new/include/linux/inventec/d5254/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/d5254/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/io_expander.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,183 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_MAGINOLIA_4AB      (10102)
+#define IOEXP_TYPE_CYPRESS_NABC       (10103)
+#define IOEXP_TYPE_MAPLE_NABC         (10104)
+#define IOEXP_TYPE_GULMOHAR_NABC      (10105)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+#define IOEXP_TYPE_TAHOE_5A           (10208)
+#define IOEXP_TYPE_TAHOE_6ABC         (10209)
+#define IOEXP_TYPE_SEQUOIA_NABC       (10210)
+#define IOEXP_TYPE_LAVENDER_P65       (10211)
+#define IOEXP_TYPE_MAPLE_0ABC         (10212)
+#define IOEXP_TYPE_GULMOHAR_7ABC      (10213)
+
+/* CPLD type define */
+#define CPLD_TYPE_COTTONWOOD          (10301)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;           /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[10];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[10]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[10];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[10];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[10];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[10];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[10];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/d5254/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/d5254/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/onie_tlvinfo.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/d5254/transceiver.h linux-3_16_53_new/include/linux/inventec/d5254/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/d5254/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5254/transceiver.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,809 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_EXTPHY_ADDR_56      (0x56)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress, Sequoia */
+#define BCM_CHIP_TYPE_TRIDENT_3         (31003)  /* Maple */
+
+#define BF_CHIP_TYPE_TOFINO             (31011)  /* Lavender */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+    /* [Prop]: External PHY offset
+     * [Desc]: It needs to be setup first if you want to access transceiver external phy.
+     * [Note]: This feature dependent on transceiver.
+     *         Currently, only 1G-RJ45 transceiver supported it.
+     */
+    uint8_t extphy_offset;
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_extphy_offset)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_extphy_reg)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+    int  (*set_extphy_offset)(struct transvr_obj_s *self, int input_val);
+    int  (*set_extphy_reg)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_mux.h linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_mux.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_swps.h linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_swps.h	2018-09-13 19:21:55.335968299 -0700
@@ -0,0 +1,865 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+#define PLATFORM_TYPE_LAVENDER      (161)
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_LAVENDER
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER)
+  #define SWPS_LAVENDER          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+    {PLATFORM_TYPE_LAVENDER,     "Lavender"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Lavender Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_LAVENDER
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s lavender_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_LAVENDER_P01P08, { {1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {1,  IOEXP_TYPE_LAVENDER_P09P16, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {2,  IOEXP_TYPE_LAVENDER_P01P08, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {3,  IOEXP_TYPE_LAVENDER_P09P16, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {4,  IOEXP_TYPE_LAVENDER_P01P08, { {9, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {9, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {9, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {5,  IOEXP_TYPE_LAVENDER_P09P16, { {10, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {10, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {10, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {6,  IOEXP_TYPE_LAVENDER_P01P08, { {11, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {11, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {11, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {7,  IOEXP_TYPE_LAVENDER_P09P16, { {12, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {12, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {12, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {8,  IOEXP_TYPE_LAVENDER_P65,    { {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xf6, 0xff}, {0xf8, 0xff}, },    /* addr[0] = I/O Expander */
+                                     },
+    },
+};
+
+struct inv_port_layout_s lavender_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  1,  2,  3,  4} },
+    { 1,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  5,  6,  7,  8} },
+    { 2,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  9, 10, 11, 12} },
+    { 3,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 13, 14, 15, 16} },
+    { 4,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 17, 18, 19, 20} },
+    { 5,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 21, 22, 23, 24} },
+    { 6,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 25, 26, 27, 28} },
+    { 7,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 29, 30, 31, 32} },
+    { 8,  25,  1,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 33, 34, 35, 36} },
+    { 9,  26,  1,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 37, 38, 39, 40} },
+    {10,  27,  1,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 41, 42, 43, 44} },
+    {11,  28,  1,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 45, 46, 47, 48} },
+    {12,  29,  1,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 49, 50, 51, 52} },
+    {13,  30,  1,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 53, 54, 55, 56} },
+    {14,  31,  1,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 57, 58, 59, 60} },
+    {15,  32,  1,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 61, 62, 63, 64} },
+    {16,  33,  2,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 65, 66, 67, 68} },
+    {17,  34,  2,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 69, 70, 71, 72} },
+    {18,  35,  2,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 73, 74, 75, 76} },
+    {19,  36,  2,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 77, 78, 79, 80} },
+    {20,  37,  2,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 81, 82, 83, 84} },
+    {21,  38,  2,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 85, 86, 87, 88} },
+    {22,  39,  2,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 89, 90, 91, 92} },
+    {23,  40,  2,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 93, 94, 95, 96} },
+    {24,  41,  3,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 97, 98, 99,100} },
+    {25,  42,  3,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {101,102,103,104} },
+    {26,  43,  3,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {105,106,107,108} },
+    {27,  44,  3,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {109,110,111,112} },
+    {28,  45,  3,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {113,114,115,116} },
+    {29,  46,  3,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {117,118,119,120} },
+    {30,  47,  3,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {121,122,123,124} },
+    {31,  48,  3,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {125,126,127,128} },
+
+    {32,  49,  4,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {129,130,131,132} },
+    {33,  50,  4,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {133,134,135,136} },
+    {34,  51,  4,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {137,138,139,140} },
+    {35,  52,  4,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {141,142,143,144} },
+    {36,  53,  4,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {145,146,147,148} },
+    {37,  54,  4,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {149,150,151,152} },
+    {38,  55,  4,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {153,154,155,156} },
+    {39,  56,  4,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {157,158,159,160} },
+
+    {40,  57,  5,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {161,162,163,164} },
+    {41,  58,  5,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {165,166,167,168} },
+    {42,  59,  5,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {169,170,171,172} },
+    {43,  60,  5,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {173,174,175,176} },
+    {44,  61,  5,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {177,178,179,180} },
+    {45,  62,  5,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {181,182,183,184} },
+    {46,  63,  5,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {185,186,187,188} },
+    {47,  64,  5,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {189,190,191,192} },
+
+    {48,  65,  6,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {193,194,195,196} },
+    {49,  66,  6,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {197,198,199,200} },
+    {50,  67,  6,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {201,202,203,204} },
+    {51,  68,  6,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {205,206,207,208} },
+    {52,  69,  6,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {209,210,211,212} },
+    {53,  70,  6,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {213,214,215,216} },
+    {54,  71,  6,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {217,218,219,220} },
+    {55,  72,  6,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {221,222,223,224} },
+
+    {56,  73,  7,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {225,226,227,228} },
+    {57,  74,  7,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {229,230,231,232} },
+    {58,  75,  7,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {233,234,235,236} },
+    {59,  76,  7,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {237,238,239,240} },
+    {60,  77,  7,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {241,242,243,244} },
+    {61,  78,  7,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {245,246,247,248} },
+    {62,  79,  7,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {249,250,251,252} },
+    {63,  80,  7,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {253,254,255,256} },
+    {64,   5,  8,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {257,258,259,260} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_vpd.h linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/inv_vpd.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/io_expander.h linux-3_16_53_new/include/linux/inventec/d5264q28b/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/io_expander.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,172 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+#define IOEXP_TYPE_LAVENDER_P01P08    (10208)
+#define IOEXP_TYPE_LAVENDER_P09P16    (10209)
+#define IOEXP_TYPE_LAVENDER_P65       (10210)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/d5264q28b/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/onie_tlvinfo.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/d5264q28b/transceiver.h linux-3_16_53_new/include/linux/inventec/d5264q28b/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/d5264q28b/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d5264q28b/transceiver.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,795 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* BF chip type define */
+#define BF_CHIP_TYPE_TOFINO             (31003)  /* Lavender */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_mux.h linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_mux.h	2018-09-14 13:32:29.664257935 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_swps.h linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_swps.h	2018-09-14 13:32:29.668258059 -0700
@@ -0,0 +1,736 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "./transceiver.h"
+#include "./io_expander.h"
+#include "./inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+#define SWPS_KERN_VER_AF_3_10 (1)
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_REDWOOD
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_vpd.h linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/inv_vpd.h	2018-09-14 13:32:29.668258059 -0700
@@ -0,0 +1,47 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+#define VPD_KERN_VER_AF_3_10  (1)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/io_expander.h linux-3_16_53_new/include/linux/inventec/d7032q28b/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/io_expander.h	2018-09-14 13:32:29.668258059 -0700
@@ -0,0 +1,169 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/d7032q28b/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/onie_tlvinfo.h	2018-09-14 13:32:29.668258059 -0700
@@ -0,0 +1,151 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+#define TLV_CODE_EEPROM_DATA    0x00
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/d7032q28b/transceiver.h linux-3_16_53_new/include/linux/inventec/d7032q28b/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/d7032q28b/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7032q28b/transceiver.h	2018-09-14 13:32:29.668258059 -0700
@@ -0,0 +1,797 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_eeprom;       int page_eeprom;       int offset_eeprom;       int length_eeprom;
+    int addr_uppage;       int page_uppage;       int offset_uppage;       int length_uppage;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+    uint8_t eeprom[128];
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_eeprom)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_uppage)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_mux.h linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_mux.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_swps.h linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_swps.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,734 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_CYPRESS_GA2
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_vpd.h linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/inv_vpd.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/io_expander.h linux-3_16_53_new/include/linux/inventec/d7054q28b/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/io_expander.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,169 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/d7054q28b/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/onie_tlvinfo.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/d7054q28b/transceiver.h linux-3_16_53_new/include/linux/inventec/d7054q28b/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/d7054q28b/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7054q28b/transceiver.h	2018-09-14 10:21:55.066774745 -0700
@@ -0,0 +1,792 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_mux.h linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_mux.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,37 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+#define MUX_RST_GPIO_249_PCA9548        (249)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_swps.h linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_swps.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,894 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.5"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+#define PLATFORM_TYPE_TAHOE         (161)
+#define PLATFORM_TYPE_SEQUOIA_GA    (171)
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_SEQUOIA_GA
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_TAHOE)
+  #define SWPS_TAHOE             (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SEQUOIA_GA)
+  #define SWPS_SEQUOIA           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+    {PLATFORM_TYPE_TAHOE,        "Tahoe"        },
+    {PLATFORM_TYPE_SEQUOIA_GA,   "Sequoia_GA"   },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_4AB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander 4 A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf0, 0xff}, {0xf0, 0xff}, }, }, /* addr[1] = I/O Expander 4 B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Tahoe Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_TAHOE
+unsigned tahoe_gpio_rest_mux = MUX_RST_GPIO_249_PCA9548;
+
+struct inv_ioexp_layout_s tahoe_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_TAHOE_6ABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[0] = I/O Expander 6 A */
+                                  {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[1] = I/O Expander 6 B */
+                                  {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {1,  IOEXP_TYPE_TAHOE_5A,   { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[0] = I/O Expander 5 A */
+    },
+};
+
+
+struct inv_port_layout_s tahoe_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  12,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    { 1,  11,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    { 2,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    { 3,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    { 4,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    { 5,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    { 6,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    { 7,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    { 8,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    { 9,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Sequoia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SEQUOIA
+unsigned sequoia_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s secquoia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SEQUOIA_NABC, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_SEQUOIA_NABC, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1 A */
+                                    {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1 B */
+                                    {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 1 C */
+    },
+    {2,  IOEXP_TYPE_SEQUOIA_NABC, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 2 A */
+                                    {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 2 B */
+                                    {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 2 C */
+    },
+    {3,  IOEXP_TYPE_SEQUOIA_NABC, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 3 A */
+                                    {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 3 B */
+                                    {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 3 C */
+    },
+    {4,  IOEXP_TYPE_SEQUOIA_NABC, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 4 A */
+                                    {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 4 B */
+                                    {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 4 C */
+    },
+    {5,  IOEXP_TYPE_SEQUOIA_NABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 5 A */
+                                    {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 5 B */
+                                    {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 C */
+    },
+    {6,  IOEXP_TYPE_SEQUOIA_NABC, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 6 A */
+                                    {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 6 B */
+                                    {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {7,  IOEXP_TYPE_SEQUOIA_NABC, { {9, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 7 A */
+                                    {9, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                    {9, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+
+struct inv_port_layout_s secquoia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9,  10,  11,  12} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,   2,   3,   4} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25,  26,  27,  28} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17,  18,  19,  20} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41,  42,  43,  44} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33,  34,  35,  36} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57,  58,  59,  60} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49,  50,  51,  52} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73,  74,  75,  76} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    {10,  20,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89,  90,  91,  92} },
+    {11,  21,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    {12,  22,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    {13,  23,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    {14,  24,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121, 122, 123, 124} },
+    {15,  25,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    {16,  26,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {137, 138, 139, 140} },
+    {17,  27,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {129, 130, 131, 132} },
+    {18,  28,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {153, 154, 155, 156} },
+    {19,  29,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {145, 146, 147, 148} },
+    {20,  30,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {169, 170, 171, 172} },
+    {21,  31,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {161, 162, 163, 164} },
+    {22,  32,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {185, 186, 187, 188} },
+    {23,  33,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {177, 178, 179, 180} },
+    {24,  34,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {201, 202, 203, 204} },
+    {25,  35,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {193, 194, 195, 196} },
+    {26,  36,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {217, 218, 219, 220} },
+    {27,  37,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {209, 210, 211, 212} },
+    {28,  38,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {233, 234, 235, 236} },
+    {29,  39,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {225, 226, 227, 228} },
+    {30,  40,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {249, 250, 251, 252} },
+    {31,  41,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {241, 242, 243, 244} },
+    {32,  45,  4,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13,  14,  15,  16} },
+    {33,  44,  4,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,   6,   7,   8} },
+    {34,  43,  4,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29,  30,  31,  32} },
+    {35,  42,  4,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21,  22,  23,  24} },
+    {36,  49,  4,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45,  46,  47,  48} },
+    {37,  48,  4,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37,  38,  39,  40} },
+    {38,  47,  4,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61,  62,  63,  64} },
+    {39,  46,  4,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    {40,  53,  5,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77,  78,  79,  80} },
+    {41,  52,  5,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    {42,  51,  5,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93,  94,  95,  96} },
+    {43,  50,  5,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    {44,  57,  5,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+    {45,  56,  5,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    {46,  55,  5,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125, 126, 127, 128} },
+    {47,  54,  5,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117, 118, 119, 120} },
+    {48,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {141, 142, 143, 144} },
+    {49,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {133, 134, 135, 136} },
+    {50,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {157, 158, 159, 160} },
+    {51,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {149, 150, 151, 152} },
+    {52,  65,  6,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {173, 174, 175, 176} },
+    {53,  64,  6,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {165, 166, 167, 168} },
+    {54,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {189, 190, 191, 192} },
+    {55,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {181, 182, 183, 184} },
+    {56,  69,  7,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {205, 206, 207, 208} },
+    {57,  68,  7,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {197, 198, 199, 200} },
+    {58,  67,  7,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {221, 222, 223, 224} },
+    {59,  66,  7,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {213, 214, 215, 216} },
+    {60,  73,  7,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {237, 238, 239, 240} },
+    {61,  72,  7,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {229, 230, 231, 232} },
+    {62,  71,  7,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {253, 254, 255, 256} },
+    {63,  70,  7,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {245, 246, 247, 248} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_vpd.h linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/inv_vpd.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/io_expander.h linux-3_16_53_new/include/linux/inventec/d7264q28b/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/io_expander.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,173 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+#define IOEXP_TYPE_TAHOE_5A           (10208)
+#define IOEXP_TYPE_TAHOE_6ABC         (10209)
+#define IOEXP_TYPE_SEQUOIA_NABC       (10210)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;           /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[10];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[10]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[10];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[10];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[10];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[10];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[10];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/d7264q28b/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/onie_tlvinfo.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, const char *strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/d7264q28b/transceiver.h linux-3_16_53_new/include/linux/inventec/d7264q28b/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/d7264q28b/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/d7264q28b/transceiver.h	2018-09-13 19:23:52.012106246 -0700
@@ -0,0 +1,792 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/inv_mux.h linux-3_16_53_new/include/linux/inventec/lavender/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/lavender/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/inv_mux.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/inv_swps.h linux-3_16_53_new/include/linux/inventec/lavender/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/lavender/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/inv_swps.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,865 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+#define PLATFORM_TYPE_LAVENDER      (161)
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_LAVENDER
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER)
+  #define SWPS_LAVENDER          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+    {PLATFORM_TYPE_LAVENDER,     "Lavender"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Lavender Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_LAVENDER
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s lavender_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_LAVENDER_P01P08, { {1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {1,  IOEXP_TYPE_LAVENDER_P09P16, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {2,  IOEXP_TYPE_LAVENDER_P01P08, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {3,  IOEXP_TYPE_LAVENDER_P09P16, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {4,  IOEXP_TYPE_LAVENDER_P01P08, { {9, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {9, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {9, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {5,  IOEXP_TYPE_LAVENDER_P09P16, { {10, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {10, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {10, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {6,  IOEXP_TYPE_LAVENDER_P01P08, { {11, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {11, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {11, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {7,  IOEXP_TYPE_LAVENDER_P09P16, { {12, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1-4 A */
+                                       {12, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1-4 B */
+                                       {12, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, },    /* addr[2] = I/O Expander 1-4 C */
+                                     },
+    },
+    {8,  IOEXP_TYPE_LAVENDER_P65,    { {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xf6, 0xff}, {0xf8, 0xff}, },    /* addr[0] = I/O Expander */
+                                     },
+    },
+};
+
+struct inv_port_layout_s lavender_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  1,  2,  3,  4} },
+    { 1,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  5,  6,  7,  8} },
+    { 2,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  9, 10, 11, 12} },
+    { 3,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 13, 14, 15, 16} },
+    { 4,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 17, 18, 19, 20} },
+    { 5,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 21, 22, 23, 24} },
+    { 6,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 25, 26, 27, 28} },
+    { 7,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 29, 30, 31, 32} },
+    { 8,  25,  1,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 33, 34, 35, 36} },
+    { 9,  26,  1,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 37, 38, 39, 40} },
+    {10,  27,  1,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 41, 42, 43, 44} },
+    {11,  28,  1,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 45, 46, 47, 48} },
+    {12,  29,  1,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 49, 50, 51, 52} },
+    {13,  30,  1,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 53, 54, 55, 56} },
+    {14,  31,  1,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 57, 58, 59, 60} },
+    {15,  32,  1,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 61, 62, 63, 64} },
+    {16,  33,  2,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 65, 66, 67, 68} },
+    {17,  34,  2,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 69, 70, 71, 72} },
+    {18,  35,  2,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 73, 74, 75, 76} },
+    {19,  36,  2,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 77, 78, 79, 80} },
+    {20,  37,  2,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 81, 82, 83, 84} },
+    {21,  38,  2,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 85, 86, 87, 88} },
+    {22,  39,  2,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 89, 90, 91, 92} },
+    {23,  40,  2,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 93, 94, 95, 96} },
+    {24,  41,  3,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 97, 98, 99,100} },
+    {25,  42,  3,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {101,102,103,104} },
+    {26,  43,  3,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {105,106,107,108} },
+    {27,  44,  3,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {109,110,111,112} },
+    {28,  45,  3,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {113,114,115,116} },
+    {29,  46,  3,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {117,118,119,120} },
+    {30,  47,  3,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {121,122,123,124} },
+    {31,  48,  3,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {125,126,127,128} },
+
+    {32,  49,  4,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {129,130,131,132} },
+    {33,  50,  4,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {133,134,135,136} },
+    {34,  51,  4,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {137,138,139,140} },
+    {35,  52,  4,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {141,142,143,144} },
+    {36,  53,  4,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {145,146,147,148} },
+    {37,  54,  4,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {149,150,151,152} },
+    {38,  55,  4,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {153,154,155,156} },
+    {39,  56,  4,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {157,158,159,160} },
+
+    {40,  57,  5,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {161,162,163,164} },
+    {41,  58,  5,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {165,166,167,168} },
+    {42,  59,  5,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {169,170,171,172} },
+    {43,  60,  5,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {173,174,175,176} },
+    {44,  61,  5,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {177,178,179,180} },
+    {45,  62,  5,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {181,182,183,184} },
+    {46,  63,  5,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {185,186,187,188} },
+    {47,  64,  5,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {189,190,191,192} },
+
+    {48,  65,  6,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {193,194,195,196} },
+    {49,  66,  6,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {197,198,199,200} },
+    {50,  67,  6,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {201,202,203,204} },
+    {51,  68,  6,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {205,206,207,208} },
+    {52,  69,  6,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {209,210,211,212} },
+    {53,  70,  6,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {213,214,215,216} },
+    {54,  71,  6,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {217,218,219,220} },
+    {55,  72,  6,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {221,222,223,224} },
+
+    {56,  73,  7,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {225,226,227,228} },
+    {57,  74,  7,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {229,230,231,232} },
+    {58,  75,  7,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {233,234,235,236} },
+    {59,  76,  7,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {237,238,239,240} },
+    {60,  77,  7,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {241,242,243,244} },
+    {61,  78,  7,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {245,246,247,248} },
+    {62,  79,  7,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {249,250,251,252} },
+    {63,  80,  7,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {253,254,255,256} },
+    {64,   5,  8,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {257,258,259,260} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/inv_vpd.h linux-3_16_53_new/include/linux/inventec/lavender/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/lavender/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/inv_vpd.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/io_expander.h linux-3_16_53_new/include/linux/inventec/lavender/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/lavender/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/io_expander.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,172 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+#define IOEXP_TYPE_LAVENDER_P01P08    (10208)
+#define IOEXP_TYPE_LAVENDER_P09P16    (10209)
+#define IOEXP_TYPE_LAVENDER_P65       (10210)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/lavender/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/lavender/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/onie_tlvinfo.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/lavender/transceiver.h linux-3_16_53_new/include/linux/inventec/lavender/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/lavender/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/lavender/transceiver.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,795 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* BF chip type define */
+#define BF_CHIP_TYPE_TOFINO             (31003)  /* Lavender */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/inv_mux.h linux-3_16_53_new/include/linux/inventec/magnolia/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/inv_mux.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,39 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+#define MUX_RST_GPIO_249_PCA9548        (249)
+#define MUX_RST_GPIO_505_PCA9548        (505)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/inv_swps.h linux-3_16_53_new/include/linux/inventec/magnolia/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/inv_swps.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,1026 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.7"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+#define PLATFORM_TYPE_TAHOE         (161)
+#define PLATFORM_TYPE_SEQUOIA_GA    (171)
+#define PLATFORM_TYPE_LAVENDER_GA   (181)
+#define PLATFORM_TYPE_LAVENDER_ONL  (182)
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_MAGNOLIA
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_TAHOE)
+  #define SWPS_TAHOE             (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SEQUOIA_GA)
+  #define SWPS_SEQUOIA           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_GA)
+  #define SWPS_LAVENDER          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_ONL)
+  #define SWPS_LAVENDER          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+    {PLATFORM_TYPE_TAHOE,        "Tahoe"        },
+    {PLATFORM_TYPE_SEQUOIA_GA,   "Sequoia_GA"   },
+    {PLATFORM_TYPE_LAVENDER_GA,  "Lavender_GA"  },
+    {PLATFORM_TYPE_LAVENDER_ONL, "Lavender_ONL" },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_4AB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander 4 A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xf0, 0xff}, {0xf0, 0xff}, }, }, /* addr[1] = I/O Expander 4 B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Tahoe Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_TAHOE
+unsigned tahoe_gpio_rest_mux = MUX_RST_GPIO_249_PCA9548;
+
+struct inv_ioexp_layout_s tahoe_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_TAHOE_6ABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[0] = I/O Expander 6 A */
+                                  {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, },    /* addr[1] = I/O Expander 6 B */
+                                  {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {1,  IOEXP_TYPE_TAHOE_5A,   { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xce, 0xb9}, {0x18, 0xe3}, }, }, /* addr[0] = I/O Expander 5 A */
+    },
+};
+
+
+struct inv_port_layout_s tahoe_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  12,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    { 1,  11,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    { 2,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    { 3,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    { 4,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    { 5,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    { 6,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    { 7,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    { 8,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    { 9,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Sequoia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SEQUOIA
+unsigned sequoia_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s sequoia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SEQUOIA_NABC, { {1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    {1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    {1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_SEQUOIA_NABC, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1 A */
+                                    {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1 B */
+                                    {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 1 C */
+    },
+    {2,  IOEXP_TYPE_SEQUOIA_NABC, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 2 A */
+                                    {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 2 B */
+                                    {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 2 C */
+    },
+    {3,  IOEXP_TYPE_SEQUOIA_NABC, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 3 A */
+                                    {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 3 B */
+                                    {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 3 C */
+    },
+    {4,  IOEXP_TYPE_SEQUOIA_NABC, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 4 A */
+                                    {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 4 B */
+                                    {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 4 C */
+    },
+    {5,  IOEXP_TYPE_SEQUOIA_NABC, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 5 A */
+                                    {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 5 B */
+                                    {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 C */
+    },
+    {6,  IOEXP_TYPE_SEQUOIA_NABC, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 6 A */
+                                    {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 6 B */
+                                    {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {7,  IOEXP_TYPE_SEQUOIA_NABC, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 7 A */
+                                    {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                    {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+
+struct inv_port_layout_s sequoia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   9,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9,  10,  11,  12} },
+    { 1,  10,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,   2,   3,   4} },
+    { 2,  11,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25,  26,  27,  28} },
+    { 3,  12,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17,  18,  19,  20} },
+    { 4,  13,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41,  42,  43,  44} },
+    { 5,  14,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33,  34,  35,  36} },
+    { 6,  15,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57,  58,  59,  60} },
+    { 7,  16,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49,  50,  51,  52} },
+    { 8,  17,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73,  74,  75,  76} },
+    { 9,  18,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65,  66,  67,  68} },
+    {10,  19,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89,  90,  91,  92} },
+    {11,  20,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81,  82,  83,  84} },
+    {12,  21,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105, 106, 107, 108} },
+    {13,  22,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97,  98,  99, 100} },
+    {14,  23,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121, 122, 123, 124} },
+    {15,  24,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113, 114, 115, 116} },
+    {16,  25,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {137, 138, 139, 140} },
+    {17,  26,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {129, 130, 131, 132} },
+    {18,  27,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {153, 154, 155, 156} },
+    {19,  28,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {145, 146, 147, 148} },
+    {20,  29,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {169, 170, 171, 172} },
+    {21,  30,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {161, 162, 163, 164} },
+    {22,  31,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {185, 186, 187, 188} },
+    {23,  32,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {177, 178, 179, 180} },
+    {24,  33,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {201, 202, 203, 204} },
+    {25,  34,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {193, 194, 195, 196} },
+    {26,  35,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {217, 218, 219, 220} },
+    {27,  36,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {209, 210, 211, 212} },
+    {28,  37,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {233, 234, 235, 236} },
+    {29,  38,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {225, 226, 227, 228} },
+    {30,  39,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {249, 250, 251, 252} },
+    {31,  40,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {241, 242, 243, 244} },
+    {32,  44,  4,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13,  14,  15,  16} },
+    {33,  43,  4,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,   6,   7,   8} },
+    {34,  42,  4,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29,  30,  31,  32} },
+    {35,  41,  4,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21,  22,  23,  24} },
+    {36,  48,  4,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45,  46,  47,  48} },
+    {37,  47,  4,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37,  38,  39,  40} },
+    {38,  46,  4,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61,  62,  63,  64} },
+    {39,  45,  4,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53,  54,  55,  56} },
+    {40,  52,  5,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77,  78,  79,  80} },
+    {41,  51,  5,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69,  70,  71,  72} },
+    {42,  50,  5,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93,  94,  95,  96} },
+    {43,  49,  5,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85,  86,  87,  88} },
+    {44,  56,  5,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109, 110, 111, 112} },
+    {45,  55,  5,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101, 102, 103, 104} },
+    {46,  54,  5,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125, 126, 127, 128} },
+    {47,  53,  5,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117, 118, 119, 120} },
+    {48,  60,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {141, 142, 143, 144} },
+    {49,  59,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {133, 134, 135, 136} },
+    {50,  58,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {157, 158, 159, 160} },
+    {51,  57,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {149, 150, 151, 152} },
+    {52,  64,  6,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {173, 174, 175, 176} },
+    {53,  63,  6,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {165, 166, 167, 168} },
+    {54,  62,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {189, 190, 191, 192} },
+    {55,  61,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {181, 182, 183, 184} },
+    {56,  68,  7,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {205, 206, 207, 208} },
+    {57,  67,  7,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {197, 198, 199, 200} },
+    {58,  66,  7,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {221, 222, 223, 224} },
+    {59,  65,  7,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {213, 214, 215, 216} },
+    {60,  72,  7,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {237, 238, 239, 240} },
+    {61,  71,  7,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {229, 230, 231, 232} },
+    {62,  70,  7,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {253, 254, 255, 256} },
+    {63,  69,  7,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {245, 246, 247, 248} },
+};
+#endif
+
+
+/* ==========================================
+ *   Lavender Layout configuration
+ * ==========================================
+ */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_GA)
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_505_PCA9548;
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_LAVENDER_ONL)
+unsigned lavender_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+#endif
+
+#ifdef SWPS_LAVENDER
+struct inv_ioexp_layout_s lavender_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SEQUOIA_NABC, { { 1, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 0 A */
+                                    { 1, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 0 B */
+                                    { 1, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0 C */
+    },
+    {1,  IOEXP_TYPE_SEQUOIA_NABC, { { 2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 1 A */
+                                    { 2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 1 B */
+                                    { 2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 1 C */
+    },
+    {2,  IOEXP_TYPE_SEQUOIA_NABC, { { 3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 2 A */
+                                    { 3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 2 B */
+                                    { 3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 2 C */
+    },
+    {3,  IOEXP_TYPE_SEQUOIA_NABC, { { 4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 3 A */
+                                    { 4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 3 B */
+                                    { 4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 3 C */
+    },
+    {4,  IOEXP_TYPE_SEQUOIA_NABC, { { 9, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 4 A */
+                                    { 9, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 4 B */
+                                    { 9, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 4 C */
+    },
+    {5,  IOEXP_TYPE_SEQUOIA_NABC, { {10, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 5 A */
+                                    {10, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 5 B */
+                                    {10, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 C */
+    },
+    {6,  IOEXP_TYPE_SEQUOIA_NABC, { {11, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 6 A */
+                                    {11, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 6 B */
+                                    {11, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 6 C */
+    },
+    {7,  IOEXP_TYPE_SEQUOIA_NABC, { {12, 0x20, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0x00, 0x00}, },    /* addr[0] = I/O Expander 7 A */
+                                    {12, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0xff}, },    /* addr[1] = I/O Expander 7 B */
+                                    {12, 0x22, {0, 1}, {2, 3}, {6, 7}, {0x00, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+    {8,  IOEXP_TYPE_LAVENDER_P65, { { 5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xF6, 0xff}, {0xF8, 0xff}, }, }, /* addr[0] = I/O Expander CPU */
+    },
+};
+
+
+struct inv_port_layout_s lavender_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  17,  0,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {188, 189, 190, 191} },
+    { 1,  18,  0,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {184, 185, 186, 187} },
+    { 2,  19,  0,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {180, 181, 182, 183} },
+    { 3,  20,  0,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {176, 177, 178, 179} },
+    { 4,  21,  0,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {172, 173, 174, 175} },
+    { 5,  22,  0,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {168, 169, 170, 171} },
+    { 6,  23,  0,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {164, 165, 166, 167} },
+    { 7,  24,  0,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {160, 161, 162, 163} },
+    { 8,  25,  1,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {156, 157, 158, 159} },
+    { 9,  26,  1,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {152, 153, 154, 155} },
+    {10,  27,  1,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {148, 149, 150, 151} },
+    {11,  28,  1,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {144, 145, 146, 147} },
+    {12,  29,  1,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {140, 141, 142, 143} },
+    {13,  30,  1,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {136, 137, 138, 139} },
+    {14,  31,  1,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {132, 133, 134, 135} },
+    {15,  32,  1,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {128, 129, 130, 131} },
+    {16,  33,  2,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  0,   1,   2,   3} },
+    {17,  34,  2,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  4,   5,   6,   7} },
+    {18,  35,  2,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {  8,   9,  10,  11} },
+    {19,  36,  2,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 12,  13,  14,  15} },
+    {20,  37,  2,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 16,  17,  18,  19} },
+    {21,  38,  2,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 20,  21,  22,  23} },
+    {22,  39,  2,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 24,  25,  26,  27} },
+    {23,  40,  2,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 28,  29,  30,  31} },
+    {24,  41,  3,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 32,  33,  34,  35} },
+    {25,  42,  3,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 36,  37,  38,  39} },
+    {26,  43,  3,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 40,  41,  42,  43} },
+    {27,  44,  3,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 44,  45,  46,  47} },
+    {28,  45,  3,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 48,  49,  50,  51} },
+    {29,  46,  3,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 52,  53,  54,  55} },
+    {30,  47,  3,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 56,  57,  58,  59} },
+    {31,  48,  3,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 60,  61,  62,  63} },
+    {32,  49,  4,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {256, 257, 258, 259} },
+    {33,  50,  4,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {260, 261, 262, 263} },
+    {34,  51,  4,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {264, 265, 266, 267} },
+    {35,  52,  4,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {268, 269, 270, 271} },
+    {36,  53,  4,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {272, 273, 274, 275} },
+    {37,  54,  4,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {276, 277, 278, 279} },
+    {38,  55,  4,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {280, 281, 282, 283} },
+    {39,  56,  4,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {284, 285, 286, 287} },
+    {40,  57,  5,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {288, 289, 290, 291} },
+    {41,  58,  5,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {292, 293, 294, 295} },
+    {42,  59,  5,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {296, 297, 298, 299} },
+    {43,  60,  5,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {300, 301, 302, 303} },
+    {44,  61,  5,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {304, 305, 306, 307} },
+    {45,  62,  5,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {308, 309, 310, 311} },
+    {46,  63,  5,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {312, 313, 314, 315} },
+    {47,  64,  5,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {316, 317, 318, 319} },
+    {48,  65,  6,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {444, 445, 446, 447} },
+    {49,  66,  6,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {440, 441, 442, 443} },
+    {50,  67,  6,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {436, 437, 438, 439} },
+    {51,  68,  6,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {432, 433, 434, 435} },
+    {52,  69,  6,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {428, 429, 430, 431} },
+    {53,  70,  6,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {424, 425, 426, 427} },
+    {54,  71,  6,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {420, 421, 422, 423} },
+    {55,  72,  6,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {416, 417, 418, 419} },
+    {56,  73,  7,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {412, 413, 414, 415} },
+    {57,  74,  7,  1, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {408, 409, 410, 411} },
+    {58,  75,  7,  2, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {404, 405, 406, 407} },
+    {59,  76,  7,  3, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {400, 401, 402, 403} },
+    {60,  77,  7,  4, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {396, 397, 398, 399} },
+    {61,  78,  7,  5, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {392, 393, 394, 395} },
+    {62,  79,  7,  6, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {388, 389, 390, 391} },
+    {63,  80,  7,  7, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, {384, 385, 386, 387} },
+    {64,   5,  8,  0, TRANSVR_TYPE_QSFP_28, BF_CHIP_TYPE_TOFINO, { 64,  65,  66,  67} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/inv_vpd.h linux-3_16_53_new/include/linux/inventec/magnolia/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/inv_vpd.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/io_expander.h linux-3_16_53_new/include/linux/inventec/magnolia/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/io_expander.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,176 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_MAGINOLIA_4AB      (10102)
+#define IOEXP_TYPE_CYPRESS_NABC       (10103)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+#define IOEXP_TYPE_TAHOE_5A           (10208)
+#define IOEXP_TYPE_TAHOE_6ABC         (10209)
+#define IOEXP_TYPE_SEQUOIA_NABC       (10210)
+#define IOEXP_TYPE_LAVENDER_P65       (10211)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;           /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[10];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[10]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[10];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[10];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[10];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[10];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[10];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[10];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/magnolia/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/onie_tlvinfo.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,151 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
+
diff -Naur linux-3_16_53_old/include/linux/inventec/magnolia/transceiver.h linux-3_16_53_new/include/linux/inventec/magnolia/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/magnolia/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/magnolia/transceiver.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,807 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_EXTPHY_ADDR_56      (0x56)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress, Sequoia */
+
+#define BF_CHIP_TYPE_TOFINO             (31011)  /* Lavender */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+    /* [Prop]: External PHY offset
+     * [Desc]: It needs to be setup first if you want to access transceiver external phy.
+     * [Note]: This feature dependent on transceiver.
+     *         Currently, only 1G-RJ45 transceiver supported it.
+     */
+    uint8_t extphy_offset;
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_extphy_offset)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_extphy_reg)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+    int  (*set_extphy_offset)(struct transvr_obj_s *self, int input_val);
+    int  (*set_extphy_reg)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/inv_mux.h linux-3_16_53_new/include/linux/inventec/redwood/inv_mux.h
--- linux-3_16_53_old/include/linux/inventec/redwood/inv_mux.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/inv_mux.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,36 @@
+#ifndef INV_MUX_H
+#define INV_MUX_H
+
+
+/* MUX basic information */
+#define MUX_GPIO_LABEL                 "SWPS_RST_MUX"
+
+/* MUX reset GPIO define */
+#define MUX_RST_GPIO_FORCE            (30100)
+#define MUX_RST_GPIO_FORCE_RANGELEY   (30101)
+#define MUX_RST_GPIO_FORCE_HEDERA     (30102)
+#define MUX_RST_GPIO_48_PAC9548          (48)
+#define MUX_RST_GPIO_69_PAC9548          (69)
+
+/* MUX relate value define */
+#define MUX_RST_WAIT_MS                   (1)
+#define MUX_RST_MEM_ADDR_RANGELEY         (0)    // TBD
+#define MUX_RST_MEM_ADDR_HEDERA       (0x548)
+
+struct mux_obj_s {
+    unsigned gpio_num;
+    int (*_pull_high)(struct mux_obj_s *self);
+    int (*_pull_low)(struct mux_obj_s *self);
+    int (*_init)(struct mux_obj_s *self);
+    int (*reset)(struct mux_obj_s *self);
+};
+
+
+void clean_mux_gpio(void);
+int  reset_mux_gpio(void);
+int  init_mux_gpio(unsigned gpio);
+
+
+#endif /* INV_MUX_H */
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/inv_swps.h linux-3_16_53_new/include/linux/inventec/redwood/inv_swps.h
--- linux-3_16_53_old/include/linux/inventec/redwood/inv_swps.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/inv_swps.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,734 @@
+#ifndef INV_SWPS_H
+#define INV_SWPS_H
+
+#include "transceiver.h"
+#include "io_expander.h"
+#include "inv_mux.h"
+
+/* Module settings */
+#define SWP_CLS_NAME          "swps"
+#define SWP_DEV_PORT          "port"
+#define SWP_DEV_MODCTL        "module"
+#define SWP_RESET_PWD         "inventec"
+#define SWP_POLLING_PERIOD    (300)  /* msec */
+#define SWP_POLLING_ENABLE    (1)
+#define SWP_AUTOCONFIG_ENABLE (1)
+
+/* Module information */
+#define SWP_AUTHOR            "Neil <liao.neil@inventec.com>"
+#define SWP_DESC              "Inventec port and transceiver driver"
+#define SWP_VERSION           "4.2.3"
+#define SWP_LICENSE           "GPL"
+
+/* Module status define */
+#define SWP_STATE_NORMAL      (0)
+#define SWP_STATE_I2C_DIE     (-91)
+
+/* [Note]:
+ *  Functions and mechanism for auto-detect platform type is ready,
+ *  But HW and BIOS not ready! We need to wait them.
+ *  So, please do not use PLATFORM_TYPE_AUTO until they are ready.
+ *  (2016.06.13)
+ */
+#define PLATFORM_TYPE_AUTO          (100)
+#define PLATFORM_TYPE_MAGNOLIA      (111)
+#define PLATFORM_TYPE_MAGNOLIA_FNC  (112)
+#define PLATFORM_TYPE_REDWOOD       (121)
+#define PLATFORM_TYPE_REDWOOD_FSL   (122)
+#define PLATFORM_TYPE_HUDSON32I_GA  (131)
+#define PLATFORM_TYPE_SPRUCE        (141)
+#define PLATFORM_TYPE_CYPRESS_GA1   (151) /* Up -> Down */
+#define PLATFORM_TYPE_CYPRESS_GA2   (152) /* Down -> Up */
+#define PLATFORM_TYPE_CYPRESS_BAI   (153) /* Down -> Up */
+/* Current running platfrom */
+#define PLATFORM_SETTINGS           PLATFORM_TYPE_REDWOOD
+
+/* Define platform flag and kernel version */
+#if (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_MAGNOLIA_FNC)
+  #define SWPS_MAGNOLIA          (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD)
+  #define SWPS_REDWOOD           (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_REDWOOD_FSL)
+  #define SWPS_REDWOOD_FSL       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_HUDSON32I_GA)
+  #define SWPS_HUDSON32I_GA      (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_SPRUCE)
+  #define SWPS_SPRUCE            (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA1)
+  #define SWPS_CYPRESS_GA1       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_GA2)
+  #define SWPS_CYPRESS_GA2       (1)
+  #define SWPS_KERN_VER_BF_3_8   (1)
+#elif (PLATFORM_SETTINGS == PLATFORM_TYPE_CYPRESS_BAI)
+  #define SWPS_CYPRESS_BAI       (1)
+  #define SWPS_KERN_VER_AF_3_10  (1)
+#endif
+
+
+struct inv_platform_s {
+    int  id;
+    char name[64];
+};
+
+struct inv_ioexp_layout_s {
+    int ioexp_id;
+    int ioexp_type;
+    struct ioexp_addr_s addr[4];
+};
+
+struct inv_port_layout_s {
+    int port_id;
+    int chan_id;
+    int ioexp_id;
+    int ioexp_offset;
+    int transvr_type;
+    int chipset_type;
+    int lane_id[8];
+};
+
+
+/* ==========================================
+ *   Inventec Platform Settings
+ * ==========================================
+ */
+struct inv_platform_s platform_map[] = {
+    {PLATFORM_TYPE_AUTO,         "Auto-Detect"  },
+    {PLATFORM_TYPE_MAGNOLIA,     "Magnolia"     },
+    {PLATFORM_TYPE_MAGNOLIA_FNC, "Magnolia_FNC" },
+    {PLATFORM_TYPE_REDWOOD,      "Redwood"      },
+    {PLATFORM_TYPE_REDWOOD_FSL,  "Redwood_FSL"  },
+    {PLATFORM_TYPE_HUDSON32I_GA, "Hudson32i"    },
+    {PLATFORM_TYPE_SPRUCE,       "Spruce"       },
+    {PLATFORM_TYPE_CYPRESS_GA1,  "Cypress_GA1"  },
+    {PLATFORM_TYPE_CYPRESS_GA2,  "Cypress_GA2"  },
+    {PLATFORM_TYPE_CYPRESS_BAI,  "Cypress_BAI"  },
+};
+
+
+/* ==========================================
+ *   Magnolia Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_MAGNOLIA
+unsigned magnolia_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s magnolia_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_MAGINOLIA_NAB, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {1,  IOEXP_TYPE_MAGINOLIA_NAB, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {2,  IOEXP_TYPE_MAGINOLIA_NAB, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {3,  IOEXP_TYPE_MAGINOLIA_NAB, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {4,  IOEXP_TYPE_MAGINOLIA_NAB, { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {5,  IOEXP_TYPE_MAGINOLIA_NAB, { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, }, }, /* addr[1] = I/O Expander N B */
+    },
+    {6,  IOEXP_TYPE_MAGINOLIA_7AB, { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[1] = I/O Expander 7 B */
+    },
+};
+
+struct inv_port_layout_s magnolia_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 16} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 15} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 14} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 13} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 24} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 23} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 22} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 21} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 28} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 27} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 26} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 25} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 32} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 31} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 30} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 29} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 48} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 47} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 46} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 45} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 52} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 51} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 50} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 49} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 56} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 55} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 54} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 53} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 60} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 59} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 58} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 57} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 64} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 63} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 62} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 61} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 68} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 67} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 66} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 65} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 72} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 71} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 70} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 69} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 76} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 75} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 74} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,  BCM_CHIP_TYPE_TRIDENT_2, { 73} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD
+unsigned redwood_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+struct inv_port_layout_s redwood_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Hudson32i Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_HUDSON32I_GA
+unsigned hudsin32iga_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s hudson32iga_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {1,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x24 */
+    },
+    {2,  IOEXP_TYPE_HUDSON32IGA_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+    {3,  IOEXP_TYPE_HUDSON32IGA_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander A    */
+                                          {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander B    */
+                                          {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 0x25 */
+    },
+};
+
+struct inv_port_layout_s hudson32iga_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  1,  2,  3,  4} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  5,  6,  7,  8} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {  9, 10, 11, 12} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 13, 14, 15, 16} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 17, 18, 19, 20} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 21, 22, 23, 24} },
+    { 6,  12,  0,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 25, 26, 27, 28} },
+    { 7,  13,  0,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 29, 30, 31, 32} },
+    { 8,  14,  1,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 33, 34, 35, 36} },
+    { 9,  15,  1,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 37, 38, 39, 40} },
+    {10,  16,  1,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 41, 42, 43, 44} },
+    {11,  17,  1,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 45, 46, 47, 48} },
+    {12,  18,  1,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 49, 50, 51, 52} },
+    {13,  19,  1,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 53, 54, 55, 56} },
+    {14,  20,  1,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 57, 58, 59, 60} },
+    {15,  21,  1,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 61, 62, 63, 64} },
+    {16,  22,  2,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 65, 66, 67, 68} },
+    {17,  23,  2,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 69, 70, 71, 72} },
+    {18,  24,  2,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 73, 74, 75, 76} },
+    {19,  25,  2,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    {20,  26,  2,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    {21,  27,  2,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 85, 86, 87, 88} },
+    {22,  28,  2,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 89, 90, 91, 92} },
+    {23,  29,  2,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 93, 94, 95, 96} },
+    {24,  30,  3,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    {25,  31,  3,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    {26,  32,  3,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    {27,  33,  3,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+    {28,  34,  3,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {113,114,115,116} },
+    {29,  35,  3,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {117,118,119,120} },
+    {30,  36,  3,  6, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {121,122,123,124} },
+    {31,  37,  3,  7, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {125,126,127,128} },
+};
+#endif
+
+
+/* ==========================================
+ *   Spruce Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_SPRUCE
+unsigned spruce_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s spruce_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_SPRUCE_7AB,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 7A  */
+                                   {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xf0, 0x33}, }, }, /* addr[2] = I/O Expander 7B  */
+    },
+};
+
+struct inv_port_layout_s spruce_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,   6,  0,  0, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 81, 82, 83, 84} },
+    { 1,   7,  0,  1, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 77, 78, 79, 80} },
+    { 2,   8,  0,  2, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, { 97, 98, 99,100} },
+    { 3,   9,  0,  3, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {101,102,103,104} },
+    { 4,  10,  0,  4, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {105,106,107,108} },
+    { 5,  11,  0,  5, TRANSVR_TYPE_QSFP_PLUS, BCM_CHIP_TYPE_TRIDENT_2, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Up->Down])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA1
+unsigned cypress_ga1_gpio_rest_mux = MUX_RST_GPIO_69_PAC9548;
+
+struct inv_ioexp_layout_s cypress_ga1_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga1_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (Inventec version [Down->Up])
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_GA2
+unsigned cypress_ga2_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_ga2_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_ga2_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 1,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 2,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 3,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 4,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 5,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 6,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 7,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 8,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    { 9,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {10,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {11,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {12,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {13,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {14,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {15,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {16,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {17,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {18,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {19,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {20,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {21,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {22,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {23,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {24,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {25,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {26,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {27,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {28,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {29,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {30,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {31,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {32,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {33,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {34,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {35,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {36,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {37,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {38,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {39,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {40,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {41,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {42,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {43,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {44,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {45,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {46,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {47,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {48,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {49,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {50,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {51,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {52,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {53,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Cypress Layout configuration (BaiDu version)
+ * ==========================================
+ */
+#ifdef SWPS_CYPRESS_BAI
+unsigned cypress_b_gpio_rest_mux = MUX_RST_GPIO_FORCE_HEDERA;
+
+struct inv_ioexp_layout_s cypress_b_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_CYPRESS_NABC,  { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {2, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {1,  IOEXP_TYPE_CYPRESS_NABC,  { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {3, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {2,  IOEXP_TYPE_CYPRESS_NABC,  { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {4, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {3,  IOEXP_TYPE_CYPRESS_NABC,  { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {5, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {4,  IOEXP_TYPE_CYPRESS_NABC,  { {6, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {6, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {6, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {5,  IOEXP_TYPE_CYPRESS_NABC,  { {7, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[0] = I/O Expander N A */
+                                     {7, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xf0}, {0xff, 0xf0}, },    /* addr[1] = I/O Expander N B */
+                                     {7, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0x00, 0x00}, }, }, /* addr[2] = I/O Expander N C */
+    },
+    {6,  IOEXP_TYPE_CYPRESS_7ABC,  { {8, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xc0, 0xc0}, },    /* addr[0] = I/O Expander 7 A */
+                                     {8, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xc0, 0xc0}, {0xff, 0xc0}, },    /* addr[1] = I/O Expander 7 B */
+                                     {8, 0x22, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 7 C */
+    },
+};
+
+struct inv_port_layout_s cypress_b_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 1,  11,  0,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  2} },
+    { 2,  10,  0,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  1} },
+    { 3,  13,  0,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  4} },
+    { 4,  12,  0,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  3} },
+    { 5,  15,  0,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  6} },
+    { 6,  14,  0,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  5} },
+    { 7,  17,  0,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  8} },
+    { 8,  16,  0,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  7} },
+    { 9,  19,  1,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 10} },
+    {10,  18,  1,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, {  9} },
+    {11,  21,  1,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 12} },
+    {12,  20,  1,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 11} },
+    {13,  23,  1,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 22} },
+    {14,  22,  1,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 21} },
+    {15,  25,  1,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 24} },
+    {16,  24,  1,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 23} },
+    {17,  27,  2,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 34} },
+    {18,  26,  2,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 33} },
+    {19,  29,  2,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 36} },
+    {20,  28,  2,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 35} },
+    {21,  31,  2,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 38} },
+    {22,  30,  2,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 37} },
+    {23,  33,  2,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 40} },
+    {24,  32,  2,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 39} },
+    {25,  35,  3,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 42} },
+    {26,  34,  3,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 41} },
+    {27,  37,  3,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 44} },
+    {28,  36,  3,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 43} },
+    {29,  39,  3,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 50} },
+    {30,  38,  3,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 49} },
+    {31,  41,  3,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 52} },
+    {32,  40,  3,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 51} },
+    {33,  43,  4,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 54} },
+    {34,  42,  4,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 53} },
+    {35,  45,  4,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 56} },
+    {36,  44,  4,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 55} },
+    {37,  47,  4,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 66} },
+    {38,  46,  4,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 65} },
+    {39,  49,  4,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 68} },
+    {40,  48,  4,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 67} },
+    {41,  51,  5,  1, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 70} },
+    {42,  50,  5,  0, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 69} },
+    {43,  53,  5,  3, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 72} },
+    {44,  52,  5,  2, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 71} },
+    {45,  55,  5,  5, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 82} },
+    {46,  54,  5,  4, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 81} },
+    {47,  57,  5,  7, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 84} },
+    {48,  56,  5,  6, TRANSVR_TYPE_SFP,     BCM_CHIP_TYPE_TOMAHAWK, { 83} },
+    {49,  59,  6,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {50,  58,  6,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {51,  61,  6,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {52,  60,  6,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {53,  63,  6,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {54,  62,  6,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+};
+#endif
+
+
+/* ==========================================
+ *   Redwood_fsl Layout configuration
+ * ==========================================
+ */
+#ifdef SWPS_REDWOOD_FSL
+unsigned redwood_fsl_gpio_rest_mux = MUX_RST_GPIO_48_PAC9548;
+
+struct inv_ioexp_layout_s redwood_fsl_ioexp_layout[] = {
+    /* IOEXP_ID / IOEXP_TYPE / { Chan_ID, Chip_addr, Read_offset, Write_offset, config_offset, data_default, conf_default } */
+    {0,  IOEXP_TYPE_REDWOOD_P01P08, { {4, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {4, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {1,  IOEXP_TYPE_REDWOOD_P09P16, { {5, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {5, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x25, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {2,  IOEXP_TYPE_REDWOOD_P01P08, { {2, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {2, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+    {3,  IOEXP_TYPE_REDWOOD_P09P16, { {3, 0x20, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[0] = I/O Expander 1-4 A */
+                                      {3, 0x21, {0, 1}, {2, 3}, {6, 7}, {0xff, 0x00}, {0x00, 0x0f}, },    /* addr[1] = I/O Expander 1-4 B */
+                                      {0, 0x24, {0, 1}, {2, 3}, {6, 7}, {0xff, 0xff}, {0xff, 0xff}, }, }, /* addr[2] = I/O Expander 5 B   */
+    },
+};
+
+
+struct inv_port_layout_s redwood_fsl_port_layout[] = {
+    /* Port_ID / Chan_ID / IOEXP_ID / IOEXP_VIRT_OFFSET / TRANSCEIVER_TYPE / BCM_CHIP_TYPE / LANE_ID */
+    { 0,  22,  0,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  1,  2,  3,  4} },
+    { 1,  23,  0,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  5,  6,  7,  8} },
+    { 2,  24,  0,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {  9, 10, 11, 12} },
+    { 3,  25,  0,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 13, 14, 15, 16} },
+    { 4,  26,  0,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 17, 18, 19, 20} },
+    { 5,  27,  0,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 21, 22, 23, 24} },
+    { 6,  28,  0,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 25, 26, 27, 28} },
+    { 7,  29,  0,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 29, 30, 31, 32} },
+    { 8,  30,  1,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 33, 34, 35, 36} },
+    { 9,  31,  1,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 37, 38, 39, 40} },
+    {10,  32,  1,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 41, 42, 43, 44} },
+    {11,  33,  1,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 45, 46, 47, 48} },
+    {12,  34,  1,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 49, 50, 51, 52} },
+    {13,  35,  1,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 53, 54, 55, 56} },
+    {14,  36,  1,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 57, 58, 59, 60} },
+    {15,  37,  1,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 61, 62, 63, 64} },
+    {16,   6,  2,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 65, 66, 67, 68} },
+    {17,   7,  2,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 69, 70, 71, 72} },
+    {18,   8,  2,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 73, 74, 75, 76} },
+    {19,   9,  2,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 77, 78, 79, 80} },
+    {20,  10,  2,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 81, 82, 83, 84} },
+    {21,  11,  2,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 85, 86, 87, 88} },
+    {22,  12,  2,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 89, 90, 91, 92} },
+    {23,  13,  2,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 93, 94, 95, 96} },
+    {24,  14,  3,  0, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, { 97, 98, 99,100} },
+    {25,  15,  3,  1, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {101,102,103,104} },
+    {26,  16,  3,  2, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {105,106,107,108} },
+    {27,  17,  3,  3, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {109,110,111,112} },
+    {28,  18,  3,  4, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {113,114,115,116} },
+    {29,  19,  3,  5, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {117,118,119,120} },
+    {30,  20,  3,  6, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {121,122,123,124} },
+    {31,  21,  3,  7, TRANSVR_TYPE_QSFP_28, BCM_CHIP_TYPE_TOMAHAWK, {125,126,127,128} },
+};
+#endif
+
+
+#endif /* INV_SWPS_H */
+
+
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/inv_vpd.h linux-3_16_53_new/include/linux/inventec/redwood/inv_vpd.h
--- linux-3_16_53_old/include/linux/inventec/redwood/inv_vpd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/inv_vpd.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,46 @@
+#ifndef INV_VPD_H
+#define INV_VPD_H
+
+#define EEPROM_CLASS   "eeprom"
+#define VPD_DEVICE     "vpd"
+#define VPD_AUTHOR     "Neil <liao.neil@inventec.com>"
+#define VPD_DESC       "Inventec eeprom vpd driver"
+#define VPD_VERSION    "1.0.0"
+#define VPD_LICENSE    "GPL"
+
+#define VPD_ENTRY_SIZE        (17)
+#define VPD_I2C_BUS           (0)
+#define VPD_I2C_ADDR          (0x53)
+
+struct register_attr {
+struct device_attribute *attr;
+char * errmsg;
+};
+
+struct vpd_device_attribute{
+    struct device_attribute dev_attr;
+    int index;
+};
+
+#define to_vpd_dev_attr(_dev_attr) \
+    container_of(_dev_attr, struct vpd_device_attribute, dev_attr)
+
+#define VPD_ATTR(_name, _mode, _show, _store, _index)   \
+    { .dev_attr = __ATTR(_name, _mode, _show, _store),  \
+    .index = _index }
+
+#define VPD_DEVICE_ATTR(_name, _mode, _show, _store, _index)    \
+    struct vpd_device_attribute vpd_dev_attr_##_name            \
+    = VPD_ATTR(_name, _mode, _show, _store, _index)
+
+#define VPD_INFO(fmt, args...) printk( KERN_INFO "[VPD] " fmt, ##args)
+#define VPD_WARN(fmt, args...) printk( KERN_WARNING "[VPD] " fmt, ##args)
+#define VPD_ERR(fmt, args...)  printk( KERN_ERR  "[VPD] " fmt, ##args)
+
+#ifdef DEBUG_VPD
+#    define VPD_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[VPD] " fmt, ##args)
+#else
+#    define VPD_DEBUG(fmt, args...)
+#endif
+
+#endif /* INV_VPD_H */
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/io_expander.h linux-3_16_53_new/include/linux/inventec/redwood/io_expander.h
--- linux-3_16_53_old/include/linux/inventec/redwood/io_expander.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/io_expander.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,169 @@
+#ifndef IO_EXPANDER_H
+#define IO_EXPANDER_H
+
+#include <linux/types.h>
+
+
+/* IOEXP type define (SFP series) */
+#define IOEXP_TYPE_MAGINOLIA_NAB      (10101)
+#define IOEXP_TYPE_CYPRESS_NABC       (10102)
+
+/* IOEXP type define (QSFP series) */
+#define IOEXP_TYPE_MAGINOLIA_7AB      (10201)
+#define IOEXP_TYPE_REDWOOD_P01P08     (10202)
+#define IOEXP_TYPE_REDWOOD_P09P16     (10203)
+#define IOEXP_TYPE_HUDSON32IGA_P01P08 (10204)
+#define IOEXP_TYPE_HUDSON32IGA_P09P16 (10205)
+#define IOEXP_TYPE_SPRUCE_7AB         (10206)
+#define IOEXP_TYPE_CYPRESS_7ABC       (10207)
+
+/* IOEXP mode define */
+#define IOEXP_MODE_POLLING            (19000)
+#define IOEXP_MODE_DIRECT             (19001)
+
+/* IOEXP state define */
+#define STATE_IOEXP_NORMAL                (0)
+#define STATE_IOEXP_INIT                 (-1)
+#define STATE_IOEXP_ABNORMAL             (-2)
+
+/* IOEXP error code define */
+#define ERR_IOEXP_NOTSUPPORT           (-100)
+#define ERR_IOEXP_UNINIT               (-101)
+#define ERR_IOEXP_BADCONF              (-102)
+#define ERR_IOEXP_ABNORMAL             (-103)
+#define ERR_IOEXP_NOSTATE              (-104)
+#define ERR_IOEXP_BADINPUT             (-105)
+#define ERR_IOEXP_UNEXCPT              (-199)
+
+
+#define SWPS_INFO(fmt, args...) printk( KERN_INFO "[SWPS] " fmt, ##args)
+#define SWPS_WARN(fmt, args...) printk( KERN_WARNING "[SWPS] " fmt, ##args)
+#define SWPS_ERR(fmt, args...)  printk( KERN_ERR  "[SWPS] " fmt, ##args)
+
+#ifdef DEBUG_SWPS
+#    define SWPS_DEBUG(fmt, args...)  printk( KERN_DEBUG  "[SWPS] " fmt, ##args)
+#else
+#    define SWPS_DEBUG(fmt, args...)
+#endif
+
+
+struct ioexp_addr_s {
+    int chan_id;
+    int chip_addr;
+    int read_offset[8];
+    int write_offset[8];
+    int conf_offset[8];
+    uint8_t data_default[8]; 
+    uint8_t conf_default[8]; 
+};
+
+struct ioexp_i2c_s {
+    int chip_id;
+    struct i2c_client  *i2c_client_p;
+    struct ioexp_i2c_s *next;
+};
+
+
+struct ioexp_bitmap_s {
+    int chip_id;        /* IOEXP chip id        */
+    int ioexp_voffset;  /* IOEXP virtual offset */
+    int bit_shift;
+};
+
+struct ioexp_map_s {
+    int chip_amount;    /* Number of chips that IOEXP object content    */
+    int data_width;     /* Number of (Read/Write/Config) bytes          */
+    struct ioexp_addr_s   *map_addr;          /* Chip address info      */
+    struct ioexp_bitmap_s  map_present[8];    /* IOEXP for SFP / QSFP   */
+    struct ioexp_bitmap_s  map_tx_disable[8]; /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_tx_fault[8];   /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_rxlos[8];      /* IOEXP for SFP          */
+    struct ioexp_bitmap_s  map_reset[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_lpmod[8];      /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_modsel[8];     /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs0[8];   /* IOEXP for QSFP         */
+    struct ioexp_bitmap_s  map_hard_rs1[8];   /* IOEXP for QSFP         */
+};
+
+struct ioexp_data_s {
+    uint8_t data[8];
+};
+
+struct ioexp_obj_s {
+
+    /* ============================
+     *  Object public property
+     * ============================
+     */
+    int ioexp_id;
+    int ioexp_type;
+
+    /* ============================
+     *  Object private property
+     * ============================
+     */
+    struct ioexp_data_s chip_data[16];   /* Max: 8-ioexp in one virt-ioexp(ioexp_obj) */
+    struct ioexp_map_s *ioexp_map_p;
+    struct ioexp_obj_s *next;
+    struct ioexp_i2c_s *i2c_head_p;
+    struct mutex lock;
+    int mode;
+    int state;
+
+    /* ===========================================
+     *  Object public functions
+     * ===========================================
+     */
+    int (*get_present)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_fault)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_rxlos)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_tx_disable)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_reset)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_lpmod)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_modsel)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs0)(struct ioexp_obj_s *self, int virt_offset);
+    int (*get_hard_rs1)(struct ioexp_obj_s *self, int virt_offset);
+    int (*set_tx_disable)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_reset)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_lpmod)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_modsel)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs0)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+    int (*set_hard_rs1)(struct ioexp_obj_s *self, int virt_offset, int input_val);
+
+    /* ===========================================
+     *  Object private functions
+     * ===========================================
+     */
+    int (*init)(struct ioexp_obj_s *self);
+    int (*check)(struct ioexp_obj_s *self);
+    int (*update_all)(struct ioexp_obj_s *self, int show_err, char *caller_name);
+    int (*fsm_4_direct)(struct ioexp_obj_s* self);
+    int (*fsm_4_polling)(struct ioexp_obj_s* self);
+};
+
+
+struct ioexp_obj_s* get_ioexp_obj(int ioexp_id);
+int  create_ioexp_obj(int ioexp_id,
+                      int ioexp_type,
+                      struct ioexp_addr_s *addr_map_p,
+                      int run_mode);
+int  init_ioexp_objs(void);
+int  check_ioexp_objs(void);
+void clean_ioexp_objs(void);
+
+void unlock_ioexp_all(void);
+int  lock_ioexp_all(void);
+
+int  check_channel_tier_1(void);
+int  resync_channel_tier_1(void);
+
+/* Macro for bit control */
+#define SWP_BIT_SET(byte_val,bit_shift)   ((byte_val) |= (1<<(bit_shift)))
+#define SWP_BIT_CLEAR(byte_val,bit_shift) ((byte_val) &= ~(1<<(bit_shift)))
+
+
+#endif /* IO_EXPANDER_H */
+
+
+
+
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/onie_tlvinfo.h linux-3_16_53_new/include/linux/inventec/redwood/onie_tlvinfo.h
--- linux-3_16_53_old/include/linux/inventec/redwood/onie_tlvinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/onie_tlvinfo.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,150 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+#include <linux/types.h>
+#define strtoul simple_strtoul
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+#define MAX_STRING_SIZE	128
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#define SYS_EEPROM_MAX_SIZE   2048
+#define SYS_EEPROM_OFFSET     0
+#define SYS_EEPROM_SIZE       SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_I2C_DEVICE "/dev/i2c-0"
+#define SYS_EEPROM_I2C_ADDR   0x53
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(struct i2c_client *pi2c_client, u_int8_t *eeprom);
+int prog_eeprom(struct i2c_client *pi2c_client,u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+//int  find_vpd_data(u_int8_t *eeprom, int i_offset, char *c_buf);
diff -Naur linux-3_16_53_old/include/linux/inventec/redwood/transceiver.h linux-3_16_53_new/include/linux/inventec/redwood/transceiver.h
--- linux-3_16_53_old/include/linux/inventec/redwood/transceiver.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-3_16_53_new/include/linux/inventec/redwood/transceiver.h	2018-09-13 19:21:55.339968441 -0700
@@ -0,0 +1,792 @@
+#ifndef TRANSCEIVER_H
+#define TRANSCEIVER_H
+
+#include <linux/types.h>
+
+/* advanced features control */
+#define TRANSVR_INFO_DUMP_ENABLE        (1)
+#define TRANSVR_INFO_CACHE_ENABLE       (1)
+#define TRANSVR_UEVENT_ENABLE           (1)
+
+/* Transceiver type define */
+#define TRANSVR_TYPE_UNKNOW_1           (0x00)
+#define TRANSVR_TYPE_UNKNOW_2           (0xff)
+#define TRANSVR_TYPE_SFP                (0x03)  /* Define for SFP, SFP+, SFP28 */
+#define TRANSVR_TYPE_QSFP               (0x0c)
+#define TRANSVR_TYPE_QSFP_PLUS          (0x0d)
+#define TRANSVR_TYPE_QSFP_28            (0x11)
+#define TRANSVR_TYPE_UNPLUGGED          (0xfa)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_FAKE               (0xfc)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_INCONSISTENT       (0xfd)  /* Define for ERROR handle */
+#define TRANSVR_TYPE_ERROR              (0xfe)  /* Define for ERROR handle */
+
+/* Transceiver class for base info */
+#define TRANSVR_CLASS_UNSPECIFIED       (0)
+#define TRANSVR_CLASS_ERROR             (-26001)
+#define TRANSVR_CLASS_1G                (26001)
+#define TRANSVR_CLASS_10G               (26011)
+#define TRANSVR_CLASS_25G               (26021)
+#define TRANSVR_CLASS_40G               (26041)
+#define TRANSVR_CLASS_100G              (26101)
+#define TRANSVR_CLASS_NO_SPERARABLE     (26901)
+#define TRANSVR_CLASS_EXTEND_COMP       (26902)
+/* Transceiver class for Optical 1G */
+#define TRANSVR_CLASS_OPTICAL           (27000)
+#define TRANSVR_CLASS_OPTICAL_100       (27001)
+#define TRANSVR_CLASS_OPTICAL_1G        (27002)
+#define TRANSVR_CLASS_OPTICAL_1G_AOC    (27003)
+#define TRANSVR_CLASS_OPTICAL_1G_SX     (27004)
+#define TRANSVR_CLASS_OPTICAL_1G_LX     (27005)
+#define TRANSVR_CLASS_OPTICAL_1G_EX     (27006)
+/* Transceiver class for Optical 10G */
+#define TRANSVR_CLASS_OPTICAL_10G       (27010)
+#define TRANSVR_CLASS_OPTICAL_10G_S_AOC (27011)
+#define TRANSVR_CLASS_OPTICAL_10G_S_SR  (27012)
+#define TRANSVR_CLASS_OPTICAL_10G_S_LR  (27013)
+#define TRANSVR_CLASS_OPTICAL_10G_S_ER  (27014)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_AOC (27015)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_SR  (27016)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_LR  (27017)
+#define TRANSVR_CLASS_OPTICAL_10G_Q_ER  (27018)
+/* Transceiver class for Optical 25G */
+#define TRANSVR_CLASS_OPTICAL_25G       (27020)
+#define TRANSVR_CLASS_OPTICAL_25G_AOC   (27021)
+#define TRANSVR_CLASS_OPTICAL_25G_SR    (27022)
+#define TRANSVR_CLASS_OPTICAL_25G_LR    (27023)
+#define TRANSVR_CLASS_OPTICAL_25G_ER    (27024)
+/* Transceiver class for Optical 40G */
+#define TRANSVR_CLASS_OPTICAL_40G       (27040)
+#define TRANSVR_CLASS_OPTICAL_40G_AOC   (27041)
+#define TRANSVR_CLASS_OPTICAL_40G_SR4   (27042)
+#define TRANSVR_CLASS_OPTICAL_40G_LR4   (27043)
+#define TRANSVR_CLASS_OPTICAL_40G_ER4   (27044)
+/* Transceiver class for Optical 100G */
+#define TRANSVR_CLASS_OPTICAL_100G      (27100)
+#define TRANSVR_CLASS_OPTICAL_100G_AOC  (27101)
+#define TRANSVR_CLASS_OPTICAL_100G_SR4  (27102)
+#define TRANSVR_CLASS_OPTICAL_100G_LR4  (27103)
+#define TRANSVR_CLASS_OPTICAL_100G_ER4  (27104)
+#define TRANSVR_CLASS_OPTICAL_100G_PSM4 (27105)
+/* Transceiver class for Copper */
+#define TRANSVR_CLASS_COPPER            (28000)
+#define TRANSVR_CLASS_COPPER_L1_1G      (28001)
+#define TRANSVR_CLASS_COPPER_L1_10G     (28011)
+#define TRANSVR_CLASS_COPPER_L4_10G     (28012)
+#define TRANSVR_CLASS_COPPER_L1_25G     (28021)
+#define TRANSVR_CLASS_COPPER_L4_40G     (28041)
+#define TRANSVR_CLASS_COPPER_L4_100G    (28101)
+/* Transceiver class for Base-T */
+#define TRANSVR_CLASS_BASE_T_1000       (29001)
+#define TRANSVR_CLASS_BASE_T_1000_up    (29002)
+/* For uevent message */
+#define TRANSVR_UEVENT_KEY_IF           "IF_TYPE"
+#define TRANSVR_UEVENT_KEY_SP           "IF_SPEED"
+#define TRANSVR_UEVENT_KEY_LANE         "IF_LANE"
+#define TRANSVR_UEVENT_UNKNOW           "UNKNOW"
+#define TRANSVR_IF_KR                   "KR"
+#define TRANSVR_IF_KR4                  "KR4"
+#define TRANSVR_IF_SR                   "SR"
+#define TRANSVR_IF_SR4                  "SR4"
+#define TRANSVR_IF_SFI                  "SFI"
+#define TRANSVR_IF_IF_GMII              "GMII"
+#define TRANSVR_IF_IF_XGMII             "XGMII"
+#define TRANSVR_IF_SP_100               "100"
+#define TRANSVR_IF_SP_1G                "1000"
+#define TRANSVR_IF_SP_10G               "10000"
+#define TRANSVR_IF_SP_25G               "25000"
+#define TRANSVR_IF_SP_40G               "40000"
+#define TRANSVR_IF_SP_100G              "100000"
+
+/* Transceiver mode define */
+#define TRANSVR_MODE_DIRECT             (21000)
+#define TRANSVR_MODE_POLLING            (21001)
+
+/* Transceiver state define
+ * [Note]
+ *  1. State is used to represent the state of "Transceiver" and "Object".
+ *  2. State for different target has different means. The description as following:
+ */
+#define STATE_TRANSVR_CONNECTED         (0)    /* [Transvr]:Be plugged in.  [Obj]:Link up,   and work normally.       */
+#define STATE_TRANSVR_NEW               (-100) /* [Transvr]:(Not used)      [Obj]:Create                              */
+#define STATE_TRANSVR_INIT              (-101) /* [Transvr]:Be plugged in.  [Obj]:Link up,   and in initial process.  */
+#define STATE_TRANSVR_ISOLATED          (-102) /* [Transvr]:Be plugged in.  [Obj]:Isolate,   and not provide service. */
+#define STATE_TRANSVR_SWAPPED           (-200) /* [Transvr]:Be plugged in.  [Obj]:(Not used)                          */
+#define STATE_TRANSVR_DISCONNECTED      (-300) /* [Transvr]:Un-plugged.     [Obj]:Link down, and not provide service. */
+#define STATE_TRANSVR_UNEXCEPTED        (-901) /* [Transvr]:Any             [Obj]:Any,       and not in expect case.  */
+
+/* Task state define */
+#define STATE_T_TASK_WAIT               (110)
+#define STATE_T_TASK_DONE               (0)
+#define STATE_T_TASK_INIT               (-110)
+#define STATE_T_TASK_FAIL               (-410)
+
+
+/* Event for task handling */
+#define EVENT_TRANSVR_TASK_WAIT         (2101)
+#define EVENT_TRANSVR_TASK_DONE         (0)
+#define EVENT_TRANSVR_TASK_FAIL         (-2101)
+/* Event for initial handling */
+#define EVENT_TRANSVR_INIT_UP           (2201)
+#define EVENT_TRANSVR_INIT_DOWN         (1)
+#define EVENT_TRANSVR_INIT_REINIT       (-2201)
+#define EVENT_TRANSVR_INIT_FAIL         (-2202)
+/* Event for others */
+#define EVENT_TRANSVR_RELOAD_FAIL       (-2301)
+#define EVENT_TRANSVR_EXCEP_INIT        (-2401)
+#define EVENT_TRANSVR_EXCEP_UP          (-2402)
+#define EVENT_TRANSVR_EXCEP_DOWN        (-2403)
+#define EVENT_TRANSVR_EXCEP_SWAP        (-2404)
+#define EVENT_TRANSVR_EXCEP_EXCEP       (-2405)
+#define EVENT_TRANSVR_EXCEP_ISOLATED    (-2406)
+#define EVENT_TRANSVR_I2C_CRASH         (-2501)
+
+/* Transceiver error code define */
+#define ERR_TRANSVR_UNINIT              (-201)
+#define ERR_TRANSVR_UNPLUGGED           (-202)
+#define ERR_TRANSVR_ABNORMAL            (-203)
+#define ERR_TRANSVR_NOSTATE             (-204)
+#define ERR_TRANSVR_NOTSUPPORT          (-205)
+#define ERR_TRANSVR_BADINPUT            (-206)
+#define ERR_TRANSVR_UPDATE_FAIL         (-207)
+#define ERR_TRANSVR_RELOAD_FAIL         (-208)
+#define ERR_TRANSVR_INIT_FAIL           (-209)
+#define ERR_TRANSVR_UNDEFINED           (-210)
+#define ERR_TRANSVR_TASK_FAIL           (-211)
+#define ERR_TRANSVR_TASK_BUSY           (-212)
+#define ERR_TRANSVR_UEVENT_FAIL         (-213)
+#define ERR_TRANSVR_FUNC_DISABLE        (-214)
+#define ERR_TRANSVR_I2C_CRASH           (-297)
+#define ERR_TRNASVR_BE_ISOLATED         (-298)
+#define ERR_TRANSVR_UNEXCPT             (-299)
+
+/* For debug */
+#define DEBUG_TRANSVR_INT_VAL           (-99)
+#define DEBUG_TRANSVR_HEX_VAL           (0xfe)
+#define DEBUG_TRANSVR_STR_VAL           "ERROR"
+
+/* For system internal */
+#define VAL_TRANSVR_COMID_ARREESS       (0x50)
+#define VAL_TRANSVR_COMID_OFFSET        (0x00)
+#define VAL_TRANSVR_8472_READY_ADDR     (0x51)
+#define VAL_TRANSVR_8472_READY_PAGE     (-1)
+#define VAL_TRANSVR_8472_READY_OFFSET   (110)
+#define VAL_TRANSVR_8472_READY_BIT      (0)
+#define VAL_TRANSVR_8472_READY_VALUE    (0)
+#define VAL_TRANSVR_8472_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_READY_ADDR     (0x50)
+#define VAL_TRANSVR_8436_READY_PAGE     (-1)
+#define VAL_TRANSVR_8436_READY_OFFSET   (2)
+#define VAL_TRANSVR_8436_READY_BIT      (0)
+#define VAL_TRANSVR_8436_READY_VALUE    (0)
+#define VAL_TRANSVR_8436_READY_ABNORMAL (0xff)
+#define VAL_TRANSVR_8436_PWD_ADDR       (0x50)
+#define VAL_TRANSVR_8436_PWD_PAGE       (-1)
+#define VAL_TRANSVR_8436_PWD_OFFSET     (123)
+#define VAL_TRANSVR_PAGE_FREE           (-99)
+#define VAL_TRANSVR_PAGE_SELECT_OFFSET  (127)
+#define VAL_TRANSVR_PAGE_SELECT_DELAY   (5)
+#define VAL_TRANSVR_TASK_RETRY_FOREVER  (-999)
+#define VAL_TRANSVR_FUNCTION_DISABLE    (-1)
+#define STR_TRANSVR_SFP                 "SFP"
+#define STR_TRANSVR_QSFP                "QSFP"
+#define STR_TRANSVR_QSFP_PLUS           "QSFP+"
+#define STR_TRANSVR_QSFP28              "QSFP28"
+
+/* For transvr buf len */
+#define LEN_TRANSVR_S_STR               (16)
+#define LEN_TRANSVR_M_STR               (32)
+#define LEN_TRANSVR_L_STR               (64)
+
+/* Optical wavelength */
+#define VAL_OPTICAL_WAVELENGTH_SR       (850)
+#define VAL_OPTICAL_WAVELENGTH_LR       (1310)
+#define VAL_OPTICAL_WAVELENGTH_ER       (1550)
+
+/* BCM chip type define */
+#define BCM_CHIP_TYPE_TRIDENT_2         (31001)  /* Magnolia, Hudson32i, Spruce */
+#define BCM_CHIP_TYPE_TOMAHAWK          (31002)  /* Redwood, Cypress */
+
+/* Info from transceiver EEPROM */
+struct eeprom_map_s {
+    int addr_br;           int page_br;           int offset_br;           int length_br;
+    int addr_cdr;          int page_cdr;          int offset_cdr;          int length_cdr;
+    int addr_comp_rev;     int page_comp_rev;     int offset_comp_rev;     int length_comp_rev;
+    int addr_connector;    int page_connector;    int offset_connector;    int length_connector;
+    int addr_diag_type;    int page_diag_type;    int offset_diag_type;    int length_diag_type;
+    int addr_extbr;        int page_extbr;        int offset_extbr;        int length_extbr;
+    int addr_ext_id;       int page_ext_id;       int offset_ext_id;       int length_ext_id;
+    int addr_id;           int page_id;           int offset_id;           int length_id;
+    int addr_len_sm;       int page_len_sm;       int offset_len_sm;       int length_len_sm;
+    int addr_len_smf;      int page_len_smf;      int offset_len_smf;      int length_len_smf;
+    int addr_len_om1;      int page_len_om1;      int offset_len_om1;      int length_len_om1;
+    int addr_len_om2;      int page_len_om2;      int offset_len_om2;      int length_len_om2;
+    int addr_len_om3;      int page_len_om3;      int offset_len_om3;      int length_len_om3;
+    int addr_len_om4;      int page_len_om4;      int offset_len_om4;      int length_len_om4;
+    int addr_option;       int page_option;       int offset_option;       int length_option;
+    int addr_rate_id;      int page_rate_id;      int offset_rate_id;      int length_rate_id;
+    int addr_rx_am;        int page_rx_am;        int offset_rx_am;        int length_rx_am;
+    int addr_rx_em;        int page_rx_em;        int offset_rx_em;        int length_rx_em;
+    int addr_rx_los;       int page_rx_los;       int offset_rx_los;       int length_rx_los;
+    int addr_rx_power;     int page_rx_power;     int offset_rx_power;     int length_rx_power;
+    int addr_soft_rs0;     int page_soft_rs0;     int offset_soft_rs0;     int length_soft_rs0;
+    int addr_soft_rs1;     int page_soft_rs1;     int offset_soft_rs1;     int length_soft_rs1;
+    int addr_temp;         int page_temp;         int offset_temp;         int length_temp;
+    int addr_trancomp;     int page_trancomp;     int offset_trancomp;     int length_trancomp;
+    int addr_trancomp_ext; int page_trancomp_ext; int offset_trancomp_ext; int length_trancomp_ext;
+    int addr_tx_bias;      int page_tx_bias;      int offset_tx_bias;      int length_tx_bias;
+    int addr_tx_disable;   int page_tx_disable;   int offset_tx_disable;   int length_tx_disable;
+    int addr_tx_eq;        int page_tx_eq;        int offset_tx_eq;        int length_tx_eq;
+    int addr_tx_fault;     int page_tx_fault;     int offset_tx_fault;     int length_tx_fault;
+    int addr_tx_power;     int page_tx_power;     int offset_tx_power;     int length_tx_power;
+    int addr_vendor_name;  int page_vendor_name;  int offset_vendor_name;  int length_vendor_name;
+    int addr_vendor_pn;    int page_vendor_pn;    int offset_vendor_pn;    int length_vendor_pn;
+    int addr_vendor_rev;   int page_vendor_rev;   int offset_vendor_rev;   int length_vendor_rev;
+    int addr_vendor_sn;    int page_vendor_sn;    int offset_vendor_sn;    int length_vendor_sn;
+    int addr_voltage;      int page_voltage;      int offset_voltage;      int length_voltage;
+    int addr_wavelength;   int page_wavelength;   int offset_wavelength;   int length_wavelength;
+};
+
+
+struct transvr_worker_s;
+
+/* Class of transceiver object */
+struct transvr_obj_s {
+
+    /* ========== Object private property ==========
+     * [Prop]: id
+     * [Desc]: Type of serial transceiver.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh /QSFP28:11h
+     */
+    uint8_t id;
+
+    /* [Prop]: connector
+     * [Desc]: Connector type.
+     * [Note]: SFP : A0h / 2
+     *         QSFP: 00h / 130
+     */
+    uint8_t connector;
+
+    /* [Prop]: transvr_comp
+     * [Desc]: Transceiver compliance code.
+     * [Note]: SFP: SFF-8472
+     *         - Normal  : A0h / offset 3-10
+     *         - Extended: A0h / offset 36
+     *         QSFP: SFF-8436 & SFF-8636
+     *         - Normal  : 00h / offset 131-138
+     *         - Extended: 00h / offset 192
+     */
+    uint8_t transvr_comp[8];
+    uint8_t transvr_comp_ext;
+
+    /* [Prop]: vendor_name
+     * [Desc]: SFP vendor name (ASCII 16 byte char).
+     * [Note]: ex:FINISAR CORP.
+     */
+    char *vendor_name;
+
+    /* [Prop]: vendor_pn
+     * [Desc]: Part number provided by SFP vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_pn;
+
+    /* [Prop]: vendor_rev
+     * [Desc]: Revision level for part number provided by vendor (ASCII 4 byte char).
+     * [Note]:
+     */
+    char *vendor_rev;
+
+    /* [Prop]: vendor_sn
+     * [Desc]: Serial number provided by vendor (ASCII 16 byte char).
+     * [Note]:
+     */
+    char *vendor_sn;
+
+    /* [Prop]: Extended identifier
+     * [Desc]: SFP:
+     *         => None
+     *
+     *         QSFP:
+     *         => This byte contained two information:
+     *         (1) Power consumption class
+     *         (2) CDR function present
+     * [Note]: Bit description as below:
+     *         [SFP]
+     *           None
+     *
+     *         [QSFP]
+     *         (1) Power consumption class:
+     *             Class 1: 1.5W (Bit6-7 = 00:)
+     *             Class 2: 2.0W (Bit6-7 = 01:)
+     *             Class 3: 2.5W (Bit6-7 = 10:)
+     *             Class 4: 3.5W (Bit6-7 = 11:)
+     *             Class 5: 4.0W (Bit0-1 = 01:)
+     *             Class 6: 4.5W (Bit0-1 = 10:)
+     *             Class 7: 5.0W (Bit0-1 = 11:)
+     *         (2) CDR function present:
+     *             Bit2: 0 = No CDR in RX
+     *                   1 = CDR present in RX
+     *             Bit3: 0 = No CDR in TX
+     *                   1 = CDR present in TX
+     */
+    uint8_t ext_id;
+
+    /* [Prop]: br
+     * [Desc]: Nominal bit rate, units of 100 MBits/sec.
+     * [Note]: SFP:03h / QSFP:0Ch / QSPF+:0Dh
+     *         has val: 0x67
+     *         no val :
+     */
+    uint8_t br;
+
+    /* [Prop]: extbr
+     * [Desc]: Extended br (00h/222)
+     * [Desc]: Nominal bit rate per channel, units of 250 Mbps.
+     *         Complements. Byte 140. See Table 32A.
+     */
+    uint8_t extbr;
+
+    /* [Prop]: len_sm
+     * [Desc]: Length (single mode)-(100's)m
+     * [Note]: This value specifies the link length that is supported by the transceiver
+     *         while operating in compliance with the applicable standards using single mode
+     *         fiber. The value is in units of 100 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 25.4 km. A value of zero means
+     *         that the transceiver does not support single mode fiber or that the length
+     *         information must be determined from the transceiver technology.
+     */
+    int len_sm;
+
+    /* [Prop]: len_smf
+     * [Desc]: Length (single mode)-km
+     * [Note]: Addition to EEPROM data from original GBIC definition. This value specifies
+     *         the link length that is supported by the transceiver while operating in
+     *         compliance with the applicable standards using single mode fiber. The value
+     *         is in units of kilometers. A value of 255 means that the transceiver supports
+     *         a link length greater than 254 km. A value of zero means that the transceiver
+     *         does not support single mode fiber or that the length information must be
+     *         determined from the transceiver technology.
+     */
+    int len_smf;
+
+    /* [Prop]: len_om1
+     * [Desc]: Link length supported for 62.5 um OM1 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om1;
+
+    /* [Prop]: len_om2
+     * [Desc]: Link length supported for 50 um OM2 fiber, units of 10 m
+     * [Note]: The value is in units of 10 meters. A value of 255 means that the
+     *         transceiver supports a link length greater than 2.54 km. A value of
+     *         zero means that the transceiver does not support 50 micron multi-mode
+     *         fiber or that the length information must be determined from the transceiver
+     *         technology.
+     */
+    int len_om2;
+
+    /* [Prop]: len_om3
+     * [Desc]: Length (50um, OM3)
+     * [Note]: This value specifies link length that is supported by the transceiver while
+     *         operating in compliance with applicable standards using 50 micron multimode
+     *         OM3 [2000 MHz*km] fiber. The value is in units of 10 meters. A value of 255
+     *         means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber
+     *         or that the length information must be determined from the transceiver technology.
+     */
+    int len_om3;
+
+    /* [Prop]: len_om4
+     * [Desc]: Length (50um, OM4) and Length (Active Cable or Copper)
+     * [Note]: For optical links, this value specifies link length that is supported by the
+     *         transceiver while operating in compliance with applicable standards using 50 micron
+     *         multimode OM4 [4700 MHz*km] fiber. The value is in units of 10 meters. A value of
+     *         255 means that the transceiver supports a link length greater than 2.54 km. A value
+     *         of zero means that the transceiver does not support 50 micron multimode fiber or that
+     *         the length information must be determined from the transceiver codes specified in Table 5-3.
+     *
+     *         For copper links, this value specifies minimum link length supported by the transceiver
+     *         while operating in compliance with applicable standards using copper cable. For active
+     *         cable, this value represents actual length. The value is in units of 1 meter. A value of 255
+     *         means the transceiver supports a link length greater than 254 meters. A value of zero means
+     *         the transceiver does not support copper or active cables or the length information must be
+     *         determined from transceiver technology. Further information about cable design, equalization,
+     *         and connectors is usually required to guarantee meeting a particular length requirement.
+     */
+    int len_om4;
+
+    /* [Prop]: comp_rev
+     * [Desc]: SFF spec revision compliance
+     * [Note]: Indicates which revision of SFF SFF-8472 (SFP) / SFF-8636 (QSFP) the transceiver
+     *         complies with. (unsigned integer)
+     */
+    uint8_t comp_rev;
+
+    /* [Prop]: CDR
+     * [Desc]: For transceivers with CDR capability, setting the CDR to ON engages the internal
+     *         retiming function. Setting the CDR to OFF enables an internal bypassing mode ,which
+     *         directs traffic around the internal CDR. (Reference: SFF-8636)
+     * [Note]: value=0xff: ON.
+     *         value=0x00: OFF.
+     */
+    uint8_t cdr;
+
+    /* [Prop]: rate_id
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Addr: A0h / Offset: 13
+     *         2. Value description:
+     *            00h  Unspecified
+     *            01h  SFF-8079 (4/2/1G Rate_Select & AS0/AS1)
+     *            02h  SFF-8431 (8/4/2G Rx Rate_Select only)
+     *            03h  Unspecified *
+     *            04h  SFF-8431 (8/4/2G Tx Rate_Select only)
+     *            05h  Unspecified *
+     *            06h  SFF-8431 (8/4/2G Independent Rx & Tx Rate_select)
+     *            07h  Unspecified *
+     *            08h  FC-PI-5 (16/8/4G Rx Rate_select only) High=16G only, Low=8G/4G
+     *            09h  Unspecified *
+     *            0Ah  FC-PI-5 (16/8/4G Independent Rx, Tx Rate_select) High=16G only,
+     *                 Low=8G/4G
+     *            0Bh  Unspecified *
+     *            0Ch  FC-PI-6 (32/16/8G Independent Rx, Tx Rate_Select)
+     *                 High=32G only, Low = 16G/8G
+     *            0Dh  Unspecified *
+     *            0Eh  10/8G Rx and Tx Rate_Select controlling the operation or locking
+     *                 modes of the internal signal conditioner, retimer or CDR, according
+     *                 to the logic table defined in Table 10-2, High Bit Rate
+     *                 (10G) =9.95-11.3 Gb/s; Low Bit Rate (8G) = 8.5 Gb/s. In this mode,
+     *                 the default value of bit 110.3 (Soft Rate Select RS(0), Table 9-11)
+     *                 and of bit 118.3 (Soft Rate Select RS(1), Table 10-1) is 1.
+     *            0Fh  Unspecified *
+     *            10h-FFh Unallocated
+     */
+    int rate_id;
+
+    /* [Prop]: soft_rs0
+     * [Desc]: Soft Rate Select 0(RX).
+     * [Note]: 1. Writing '1' selects full bandwidth operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(0) or RS(0) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 110 / Bit: 3
+     */
+    uint8_t soft_rs0;
+
+    /* [Prop]: soft_rs1
+     * [Desc]: Soft Rate Select 1(TX).
+     * [Note]: 1. Writing '1' selects full bandwidth TX operation.
+     *         2. This bit is "OR'd with the hard Rate_Select, AS(1) or RS(1) pin value.
+     *         3. Default at power up is logic zero/low
+     *         4. Addr: A2h / Offset: 118 / Bit: 3
+     */
+    uint8_t soft_rs1;
+
+    /* [Prop]: diag_type
+     * [Desc]: DIAGNOSTIC MONITORING TYPE (A0h/92)
+     * [Note]: Description in SFF-8472 as below:
+     *         Bit7: Reserved for legacy diagnostic implementations. Must be '0' for compliance
+     *               with this document.
+     *         Bit6: Digital diagnostic monitoring implemented (described in this document).
+     *               Must be '1' for compliance with this document.
+     *         Bit5 Internally calibrated
+     *         Bit4 Externally calibrated
+     *         Bit3 Received power measurement type.0 = OMA, 1 = average power
+     *         Bit2 Address change required see section above, "addressing modes"
+     *         Bit1-0 Unallocated
+     */
+    uint8_t diag_type;
+
+    /* [Prop]: curr_temp
+     * [Desc]: Transceiver Current Temperature (A2h/96-97)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 96: High byte
+     *         3. 97: Low byte
+     *         4. This feature only for SFP
+     */
+    uint8_t curr_temp[2];
+
+    /* [Prop]: curr_vol
+     * [Desc]: Transceiver Current Voltage (SFP:A2h/108-109; QSFP:00h/22-23)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 98: High byte
+     *         3. 99: Low byte
+     *         4. This feature only for SFP
+     *         5. Internally measured transceiver supply voltage. Represented
+     *            as a 16 bit unsigned integer with the voltage defined as the
+     *            full 16 bit value (0-65535) with LSB equal to 100 uVolt,
+     *            yielding a total range of 0 to +6.55 Volts
+     */
+    uint8_t curr_voltage[2];
+
+    /* [Prop]: curr_tx_bias
+     * [Desc]: Transceiver TX Bias Current (SFP:A2h/100-101; QSFP:00h/26-27)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 100: High byte
+     *         3. 101: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX bias current in uA. Represented as a 16 bit unsigned
+     *            integer with the current defined as the full 16 bit value (0-65535)
+     *            with LSB equal to 2 uA, yielding a total range of 0 to 131 mA.
+     *            Accuracy is vendor specific but must be better than 10% of the
+     *            manufacturer's nominal value over specified operating temperature
+     *            and voltage.
+     */
+    uint8_t curr_tx_bias[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured TX output power in mW. Represented as a 16 bit unsigned
+     *         integer with the power defined as the full 16 bit value (0-65535)
+     *         with LSB equal to 0.1 uW, yielding a total range of 0 to 6.5535 mW
+     *         (~ -40 to +8.2 dBm). Data is assumed to be based on measurement of
+     *         laser monitor photodiode current. It is factory calibrated to absolute
+     *         units using the most representative fiber output type. Accuracy is
+     *         vendor specific but must be better than 3dB over specified temperature
+     *          and voltage. Data is not valid when the transmitter is disabled.
+     */
+    uint8_t curr_tx_power[8];
+
+    /* [Prop]: curr_tx_power
+     * [Desc]: Transceiver TX Output Power (A2h/102-103)
+     * [Note]: 1. Dependent on diag_type.
+     *         2. 102: High byte
+     *         3. 103: Low byte
+     *         4. This feature only for SFP
+     *         5. Measured RX received optical power in mW. Value can represent either
+     *         average received power or OMA depending upon how bit 3 of byte 92 (A0h)
+     *         is set. Represented as a 16 bit unsigned integer with the power defined
+     *         as the full 16 bit value (0-65535) with LSB equal to 0.1 uW, yielding a
+     *         total range of 0 to 6.5535 mW (~ -40 to +8.2 dBm). Absolute accuracy is
+     *         dependent upon the exact optical wavelength. For the vendor specified
+     *         wavelength, accuracy shall be better than 3dB over specified temperature
+     *         and voltage.
+     */
+    uint8_t curr_rx_power[8];
+
+    /* [Prop]: wavelength
+     * [Desc]: Wavelength or Copper Cable Attenuation
+     * [Note]: (Following is info from SFF-8636)
+     *         For optical free side devices, this parameter identifies the nominal
+     *         transmitter output wavelength at room temperature. This parameter is a
+     *         16-bit hex value with Byte 186 as high order byte and Byte 187 as low
+     *         order byte. The laser wavelength is equal to the 16-bit integer value
+     *         divided by 20 in nm (units of 0.05 nm). This resolution should be adequate
+     *         to cover all relevant wavelengths yet provide enough resolution for all
+     *         expected DWDM applications. For accurate representation of controlled
+     *         wavelength applications, this value should represent the center of the
+     *         guaranteed wavelength range. If the free side device is identified as
+     *         copper cable these registers will be used to define the cable attenuation.
+     *         An indication of 0 dB attenuation refers to the case where the attenuation
+     *         is not known or is unavailable.
+     *         Byte 186 (00-FFh) is the copper cable attenuation at 2.5 GHz in units of 1 dB.
+     *         Byte 187 (00-FFh) is the copper cable attenuation at 5.0 GHz in units of 1 dB.
+     */
+    uint8_t wavelength[2];
+
+    /* [Prop]: Amplitude control
+     * [Desc]: Amplitude control
+     * [Note]: QSFP28  => SFF-8636 03H Byte-238/239
+     */
+    uint8_t rx_am[2];
+
+    /* [Prop]: Emphasis control
+     * [Desc]: Emphasis control
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-115
+     *         QSFP28  => SFF-8636 03H Byte-236/237
+     */
+    uint8_t rx_em[2];
+
+    /* [Prop]: Soft Rx LOS
+     * [Desc]: Soft Rx LOS which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 3:
+     *          - Bit 0: L-Rx1 LOS
+     *          - Bit 1: L-Rx2 LOS
+     *          - Bit 2: L-Rx3 LOS
+     *          - Bit 3: L-Rx4 LOS
+     */
+    uint8_t rx_los;
+
+    /* [Prop]: Soft Tx Disable
+     * [Desc]: Soft Tx Disable which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Disable
+     *          - Bit 1: Tx2 Disable
+     *          - Bit 2: Tx3 Disable
+     *          - Bit 3: Tx4 Disable
+     */
+    uint8_t tx_disable;
+
+    /* [Prop]: Soft Tx Fault
+     * [Desc]: Soft Tx Fault which provide by transceiver
+     * [Note]: (Following is info from SFF-8636)
+     *         Byte 86:
+     *          - Bit 0: Tx1 Fault
+     *          - Bit 1: Tx2 Fault
+     *          - Bit 2: Tx3 Fault
+     *          - Bit 3: Tx4 Fault
+     */
+    uint8_t tx_fault;
+
+    /* [Prop]: Transceiver EQUALIZATION
+     * [Desc]: Transceiver EQUALIZATION
+     * [Note]: SFP+/28 => SFF-8472 A2H Byte-114
+     *         QSFP28  => SFF-8636 03H Byte-234/235
+     */
+    uint8_t tx_eq[2];
+
+    /* [Prop]: OPTION VALUES
+     * [Desc]: The bits in the option field shall specify the options implemented in the transceiver.
+     * [Note]: SFP+/28  => SFF-8472 A0H Byte-64/65
+     *         QSFP+/28 => SFF-8636 00H Byte-193/195
+     */
+    uint8_t option[3];
+
+
+    /* ========== Object private property ==========
+     */
+    struct device       *transvr_dev_p;
+    struct eeprom_map_s *eeprom_map_p;
+    struct i2c_client   *i2c_client_p;
+    struct ioexp_obj_s  *ioexp_obj_p;
+    struct transvr_worker_s *worker_p;
+    struct mutex lock;
+    char swp_name[32];
+    int auto_config;
+    int auto_tx_disable;
+    int chan_id;
+    int chipset_type;
+    int curr_page;
+    int info;
+    int ioexp_virt_offset;
+    int lane_id[8];
+    int layout;
+    int mode;
+    int retry;
+    int state;
+    int temp;
+    int type;
+
+    /* ========== Object public functions ==========
+     */
+    int  (*get_id)(struct transvr_obj_s *self);
+    int  (*get_ext_id)(struct transvr_obj_s *self);
+    int  (*get_connector)(struct transvr_obj_s *self);
+    int  (*get_vendor_name)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_pn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_rev)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_vendor_sn)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_power_cls)(struct transvr_obj_s *self);
+    int  (*get_br)(struct transvr_obj_s *self);
+    int  (*get_len_sm)(struct transvr_obj_s *self);
+    int  (*get_len_smf)(struct transvr_obj_s *self);
+    int  (*get_len_om1)(struct transvr_obj_s *self);
+    int  (*get_len_om2)(struct transvr_obj_s *self);
+    int  (*get_len_om3)(struct transvr_obj_s *self);
+    int  (*get_len_om4)(struct transvr_obj_s *self);
+    int  (*get_comp_rev)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_1)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10)(struct transvr_obj_s *self);
+    int  (*get_comp_eth_10_40)(struct transvr_obj_s *self);
+    int  (*get_comp_extend)(struct transvr_obj_s *self);
+    int  (*get_cdr)(struct transvr_obj_s *self);
+    int  (*get_rate_id)(struct transvr_obj_s *self);
+    int  (*get_soft_rs0)(struct transvr_obj_s *self);
+    int  (*get_soft_rs1)(struct transvr_obj_s *self);
+    int  (*get_info)(struct transvr_obj_s *self);
+    int  (*get_if_type)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_speed)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_if_lane)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_temp)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_curr_vol)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_rx_los)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_soft_tx_fault)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_auto_tx_disable)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_bias)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_power)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_tx_eq)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_am)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_rx_em)(struct transvr_obj_s *self, char *buf_p);
+    int  (*get_wavelength)(struct transvr_obj_s *self, char *buf_p);
+    int  (*set_cdr)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs0)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_rs1)(struct transvr_obj_s *self, int input_val);
+    int  (*set_soft_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_auto_tx_disable)(struct transvr_obj_s *self, int input_val);
+    int  (*set_tx_eq)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_am)(struct transvr_obj_s *self, int input_val);
+    int  (*set_rx_em)(struct transvr_obj_s *self, int input_val);
+
+    /* ========== Object private functions ==========
+     */
+    int (*init)(struct transvr_obj_s *self);
+    int (*clean)(struct transvr_obj_s *self);
+    int (*check)(struct transvr_obj_s *self);
+    int (*update_all)(struct transvr_obj_s *self, int show_err);
+    int (*fsm_4_direct)(struct transvr_obj_s* self, char *caller_name);
+    int (*fsm_4_polling)(struct transvr_obj_s* self, char *caller_name);
+    int (*send_uevent)(struct transvr_obj_s* self, enum kobject_action u_action);
+    int (*dump_all)(struct transvr_obj_s* self);
+};
+
+
+/* For AVL Mapping */
+struct transvr_avl_s {
+    char vendor_name[32];
+    char vendor_pn[32];
+    int (*init)(struct transvr_obj_s *self);
+};
+
+
+/* Worker for long term task of transceiver */
+struct transvr_worker_s {
+    /* Task Parameter */
+    struct transvr_obj_s *transvr_p;
+    struct transvr_worker_s *next_p;
+    struct transvr_worker_s *pre_p;
+    unsigned long trigger_time;
+    char func_name[64];
+    int retry;
+    int state;
+
+    /* Task private data */
+    void *p_data;
+
+    /* Call back function */
+    int (*main_task)(struct transvr_worker_s *task);
+    int (*post_task)(struct transvr_worker_s *task);
+};
+
+
+struct transvr_obj_s *
+create_transvr_obj(char *swp_name,
+                   int chan_id,
+                   struct ioexp_obj_s *ioexp_obj_p,
+                   int ioexp_virt_offset,
+                   int transvr_type,
+                   int chipset_type,
+                   int run_mode);
+
+void lock_transvr_obj(struct transvr_obj_s *self);
+void unlock_transvr_obj(struct transvr_obj_s *self);
+int isolate_transvr_obj(struct transvr_obj_s *self);
+
+int resync_channel_tier_2(struct transvr_obj_s *self);
+
+void alarm_msg_2_user(struct transvr_obj_s *self, char *emsg);
+
+#endif /* TRANSCEIVER_H */
+
+
+
+
